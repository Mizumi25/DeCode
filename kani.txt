// @/Components/Forge/CanvasComponent.jsx - Enhanced for True Responsive Canvas Sizing
import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Square, Sparkles, Monitor, Tablet, Smartphone, Move, RotateCcw, GripVertical } from 'lucide-react';

import SectionDropZone from './SectionDropZone';
import EmptyCanvasState from './EmptyCanvasState';
import SelectionOverlay from './SelectionOverlay';
import DragSnapLines from './DragSnapLines';


import { useEditorStore } from '@/stores/useEditorStore';
import { useForgeUndoRedoStore } from '@/stores/useForgeUndoRedoStore';



import { 
  DndContext, 
  closestCenter,
  PointerSensor,
  TouchSensor,
  useSensor,
  useSensors,
  DragOverlay
} from '@dnd-kit/core';
import {
  SortableContext,
  verticalListSortingStrategy,
  useSortable
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';



// CREATE A SEPARATE COMPONENT - Add this BEFORE your main CanvasComponent
const SortableComponentWrapper = ({ 
  component, 
  index, 
  depth, 
  parentId,
  children,
  onComponentClick,
  selectedComponent,
  overId
}) => {
  const isSelected = selectedComponent === component.id;
  
  // ⭐ CRITICAL: Hooks must be called unconditionally at component level
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ 
    id: component.id,
    data: { component, depth, parentId }
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0 : 1,
    zIndex: isDragging ? 9999 : component.zIndex || depth,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      {...listeners}
    >
      {children}
    </div>
  );
};






const CanvasComponent = ({
  canvasRef,
  canvasComponents,
  selectedComponent,
  dragState,
  dragPosition,
  isCanvasSelected,
  componentLibraryService,
  onCanvasDragOver,
  onCanvasDrop,
  onCanvasClick,
  onComponentClick,
  onPropertyUpdate,
  isMobile,
  currentFrame,
  isFrameSwitching,
  frameType = 'page',
  responsiveMode,
  zoomLevel,
  gridVisible,
  projectId,  // ADD THIS
  setFrameCanvasComponents, // ADD THIS
  onReorderDragStart,
  onReorderDragOver,
  onReorderDrop,
  onReorderDragEnd,
  draggedItem,
  dragOverItem,
}) => {
  // Get responsive state from EditorStore
  const {
    getCurrentCanvasDimensions,
    getResponsiveDeviceInfo,
    getResponsiveScaleFactor,
    getResponsiveCanvasClasses,
    getResponsiveGridBackground
  } = useEditorStore();
  
  
  // Get undo/redo functionality
  const { pushHistory, actionTypes } = useForgeUndoRedoStore();

  // Local state for canvas interactions
  const [isDraggingComponent, setIsDraggingComponent] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [resizingComponent, setResizingComponent] = useState(null);
  
  
  const [activeId, setActiveId] = useState(null);
  const [overId, setOverId] = useState(null);
  const [draggedComponent, setDraggedComponent] = useState(null);

  // Get responsive device info and dimensions
  const deviceInfo = getResponsiveDeviceInfo();
  const scaleFactor = getResponsiveScaleFactor();
  const canvasClasses = getResponsiveCanvasClasses();
  const canvasDimensions = getCurrentCanvasDimensions();

  // CRITICAL: Define actual canvas dimensions based on responsive mode
  const getCanvasSize = () => {
    switch (responsiveMode) {
      case 'mobile':
        return {
          width: 375,
          height: 667,
          maxWidth: '375px',
          deviceName: 'iPhone SE'
        };
      case 'tablet':
        return {
          width: 768,
          height: 1024,
          maxWidth: '768px',
          deviceName: 'iPad'
        };
      case 'desktop':
      default:
        return {
          width: '100%',
          height: 'auto',
          maxWidth: 'none',
          deviceName: 'Desktop'
        };
    }
  };

  const canvasSize = getCanvasSize();
  
  
  // Configure dnd-kit sensors with long press for mobile
  // REPLACE your existing sensors with:
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(TouchSensor, {
      activationConstraint: {
        delay: 500, // ⭐ Long press: 500ms
        tolerance: 5,
      },
    })
  );

  // Flatten components for reordering
  const flattenForReorder = useCallback((components, parentId = null) => {
    let result = [];
    components.forEach(comp => {
      result.push({ ...comp, parentId });
      if (comp.children?.length > 0) {
        result = result.concat(flattenForReorder(comp.children, comp.id));
      }
    });
    return result;
  }, []);

  const flatComponents = useMemo(() => 
    flattenForReorder(canvasComponents), 
    [canvasComponents, flattenForReorder]
  );
  
  

  // Document flow components (those that should flow naturally)
  const flowComponents = ['div', 'section', 'header', 'main', 'footer', 'nav', 'article', 'aside', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p'];
  
  // Absolute positioned components (those that need precise positioning)
  const absoluteComponents = ['button', 'badge', 'avatar', 'input', 'searchbar'];
  
  // Handle component direct manipulation (drag, resize)
  const handleComponentMouseDown = useCallback((e, componentId) => {
    e.stopPropagation();
    
    const component = canvasComponents.find(c => c.id === componentId);
    if (!component) return;

    const rect = e.currentTarget.getBoundingClientRect();
    const canvasRect = canvasRef.current.getBoundingClientRect();
    
    setIsDraggingComponent(componentId);
    setDragOffset({
      x: e.clientX - (component.position.x + canvasRect.left),
      y: e.clientY - (component.position.y + canvasRect.top)
    });

    // Select component
    onComponentClick(componentId, e);

    let hasMoved = false;
    const initialPosition = { ...component.position };
    
    const handleMouseMove = (moveEvent) => {
      const newX = moveEvent.clientX - canvasRect.left - dragOffset.x;
      const newY = moveEvent.clientY - canvasRect.top - dragOffset.y;
      
      // Constrain to canvas bounds - use actual canvas size for responsive modes
      const maxWidth = responsiveMode === 'desktop' ? canvasRect.width - 100 : canvasSize.width - 100;
      const maxHeight = responsiveMode === 'desktop' ? canvasRect.height - 50 : 600; // Reasonable constraint for mobile/tablet
      
      const constrainedX = Math.max(0, Math.min(newX, maxWidth));
      const constrainedY = Math.max(0, Math.min(newY, maxHeight));
      
      // Check if actually moved significantly
      const deltaX = Math.abs(constrainedX - initialPosition.x);
      const deltaY = Math.abs(constrainedY - initialPosition.y);
      
      if (deltaX > 1 || deltaY > 1) {
        hasMoved = true;
      }
      
      onPropertyUpdate(componentId, 'position', { x: constrainedX, y: constrainedY });
    };
    
    const handleMouseUp = () => {
      setIsDraggingComponent(false);
      
      if (hasMoved && currentFrame && pushHistory && actionTypes) {
        const finalPosition = canvasComponents.find(c => c.id === componentId)?.position;
        if (finalPosition) {
          pushHistory(currentFrame, canvasComponents, actionTypes.MOVE, {
            componentName: component.name || component.type,
            componentId,
            initialPosition,
            finalPosition
          });
        }
      }
      
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }, [canvasComponents, dragOffset, onPropertyUpdate, onComponentClick, responsiveMode, canvasSize, currentFrame, pushHistory, actionTypes]);
  
  
    // Handle drag-to-reorder
  const handleDragEnd = useCallback((result) => {
    if (!result.destination) return;
    
    const sourceIndex = result.source.index;
    const destIndex = result.destination.index;
    
    if (sourceIndex === destIndex) return;
    
    const items = Array.from(canvasComponents);
    const [reorderedItem] = items.splice(sourceIndex, 1);
    items.splice(destIndex, 0, reorderedItem);
    
    // Update z-index and sort_order based on new positions
    const updatedItems = items.map((item, index) => ({
        ...item,
        zIndex: index,
        sortOrder: index
    }));
    
    setFrameCanvasComponents(prev => ({
        ...prev,
        [currentFrame]: updatedItems
    }));
    
    // Push to history
    if (pushHistory && actionTypes) {
        pushHistory(currentFrame, updatedItems, actionTypes.MOVE, {
            componentName: reorderedItem.name || reorderedItem.type,
            componentId: reorderedItem.id,
            action: 'reorder',
            fromIndex: sourceIndex,
            toIndex: destIndex
        });
    }
    
    // Auto-save after reorder
    setTimeout(() => {
        if (componentLibraryService?.saveProjectComponents) {
            componentLibraryService.saveProjectComponents(projectId, currentFrame, updatedItems);
        }
    }, 500);
    
}, [canvasComponents, currentFrame, pushHistory, actionTypes, setFrameCanvasComponents, componentLibraryService, projectId]);





  // REPLACE your handleNestedDragEnd function with this FIXED version:
const handleNestedDragEnd = useCallback((result, containerId = 'root') => {
  console.log('Nested drag end:', result, 'in container:', containerId);
  
  if (!result.destination) {
    console.log('No destination, drag cancelled');
    return;
  }
  
  const { source, destination, draggableId } = result;
  
  // Extract container IDs
  const sourceContainerId = source.droppableId === 'canvas-root' 
    ? null 
    : source.droppableId.replace('container-', '');
    
  const destContainerId = destination.droppableId === 'canvas-root' 
    ? null 
    : destination.droppableId.replace('container-', '');
  
  console.log('Source container:', sourceContainerId, 'Dest container:', destContainerId);
  
  // Deep clone components
  let updatedComponents = JSON.parse(JSON.stringify(canvasComponents));
  
  // Same container reorder
  if (sourceContainerId === destContainerId) {
    console.log('Reordering within same container');
    
    if (sourceContainerId === null) {
      // Root level reorder
      const [moved] = updatedComponents.splice(source.index, 1);
      updatedComponents.splice(destination.index, 0, moved);
    } else {
      // Nested reorder
      updatedComponents = reorderWithinContainer(
        updatedComponents, 
        sourceContainerId, 
        source.index, 
        destination.index
      );
    }
  } 
  // Move between containers
  else {
    console.log('Moving between containers');
    updatedComponents = moveBetweenContainers(
      updatedComponents,
      draggableId,
      sourceContainerId,
      destContainerId,
      source.index,
      destination.index
    );
  }
  
  // Update sortOrder
  const updateSortOrders = (comps) => {
    comps.forEach((comp, index) => {
      comp.sortOrder = index;
      comp.zIndex = index;
      if (comp.children) {
        updateSortOrders(comp.children);
      }
    });
  };
  updateSortOrders(updatedComponents);
  
  // Update state
  setFrameCanvasComponents(prev => ({
    ...prev,
    [currentFrame]: updatedComponents
  }));
  
  // Push to history
  if (pushHistory && actionTypes) {
    pushHistory(currentFrame, updatedComponents, actionTypes.MOVE, {
      componentId: draggableId,
      action: sourceContainerId === destContainerId ? 'reorder' : 'move_container',
      fromContainer: sourceContainerId || 'root',
      toContainer: destContainerId || 'root',
      fromIndex: source.index,
      toIndex: destination.index
    });
  }
  
  // Auto-save
  setTimeout(() => {
    if (componentLibraryService?.saveProjectComponents) {
      componentLibraryService.saveProjectComponents(projectId, currentFrame, updatedComponents);
    }
  }, 500);
  
  console.log('Drag end completed, updated components:', updatedComponents.length);
  
}, [canvasComponents, currentFrame, pushHistory, actionTypes, componentLibraryService, projectId, setFrameCanvasComponents]);






const handleDndDragStart = useCallback((event) => {
    const { active } = event;
    setActiveId(active.id);
    
    // Find the component being dragged
    const component = flatComponents.find(c => c.id === active.id);
    setDraggedComponent(component);
    
    console.log('Canvas reorder drag started:', active.id);
    
    if ('vibrate' in navigator) {
      navigator.vibrate(50);
    }
  }, [flatComponents]);

  const handleDndDragOver = useCallback((event) => {
    const { over } = event;
    setOverId(over?.id || null);
  }, []);

  const handleDndDragEnd = useCallback((event) => {
    const { active, over } = event;
    
    setActiveId(null);
    setOverId(null);
    setDraggedComponent(null);

    if (!over || active.id === over.id) return;

    const oldIndex = flatComponents.findIndex(c => c.id === active.id);
    const newIndex = flatComponents.findIndex(c => c.id === over.id);

    if (oldIndex === -1 || newIndex === -1) return;

    console.log('Reordering:', active.id, 'from', oldIndex, 'to', newIndex);

    // Array move utility
    const arrayMove = (array, from, to) => {
      const newArray = [...array];
      const [movedItem] = newArray.splice(from, 1);
      newArray.splice(to, 0, movedItem);
      return newArray;
    };

    // Rebuild tree from flat array
    const rebuildTree = (flatArray) => {
      const map = new Map();
      const roots = [];

      flatArray.forEach(item => {
        map.set(item.id, { ...item, children: [] });
      });

      flatArray.forEach(item => {
        const node = map.get(item.id);
        if (item.parentId && map.has(item.parentId)) {
          map.get(item.parentId).children.push(node);
        } else {
          roots.push(node);
        }
      });

      return roots;
    };

    const reorderedFlat = arrayMove(flatComponents, oldIndex, newIndex);
    const reorderedTree = rebuildTree(reorderedFlat);

    setFrameCanvasComponents(prev => ({
      ...prev,
      [currentFrame]: reorderedTree
    }));

    if (pushHistory && actionTypes) {
      pushHistory(currentFrame, reorderedTree, actionTypes.MOVE, {
        componentId: active.id,
        fromIndex: oldIndex,
        toIndex: newIndex
      });
    }

    setTimeout(() => {
      if (componentLibraryService?.saveProjectComponents) {
        componentLibraryService.saveProjectComponents(projectId, currentFrame, reorderedTree);
      }
    }, 500);

    if ('vibrate' in navigator) {
      navigator.vibrate(30);
    }
  }, [flatComponents, currentFrame, projectId, componentLibraryService, pushHistory, actionTypes, setFrameCanvasComponents]);

  const handleDndDragCancel = useCallback(() => {
    setActiveId(null);
    setOverId(null);
    setDraggedComponent(null);
  }, []);
  




// NOW UPDATE your renderComponent to USE this wrapper:
const renderComponent = useCallback((component, index, parentStyle = {}, depth = 0, parentId = null) => {
  const isSelected = selectedComponent === component.id;
  const isLayout = component.isLayoutContainer || 
                   ['section', 'container', 'div', 'flex', 'grid'].includes(component.type);
  
  if (depth > 20) {
    console.warn('Maximum nesting depth reached:', component.id);
    return null;
  }
  
  // Your existing component rendering logic...
  const componentStyles = {
    display: component.style?.display || (isLayout ? 'block' : 'inline-block'),
    flexDirection: component.style?.flexDirection,
    justifyContent: component.style?.justifyContent,
    alignItems: component.style?.alignItems,
    gap: component.style?.gap,
    width: component.style?.width || (isLayout ? '100%' : 'auto'),
    minHeight: component.style?.minHeight || (isLayout ? '100px' : 'auto'),
    padding: component.style?.padding || (isLayout ? '24px' : '0'),
    backgroundColor: component.style?.backgroundColor || 'transparent',
    ...component.style,
  };

  // LAYOUT CONTAINER
  if (isLayout) {
    const layoutContent = (
      <motion.div
        key={component.id}
        style={componentStyles}
        data-component-id={component.id}
        data-depth={depth}
        data-is-layout="true"
        data-parent-id={parentId || 'root'}
        className={`
          relative group layout-container 
          ${isSelected ? 'ring-2 ring-blue-500' : ''}
          ${overId === component.id ? 'ring-2 ring-green-400' : ''}
        `}
        onClick={(e) => {
          e.stopPropagation();
          onComponentClick(component.id, e);
        }}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: -20 }}
        transition={{ duration: 0.2 }}
      >
        {component.children && component.children.length > 0 ? (
          <SortableContext 
            items={component.children.map(c => c.id)}
            strategy={verticalListSortingStrategy}
          >
            <div className="space-y-2">
              {component.children.map((child, childIndex) => 
                renderComponent(child, childIndex, componentStyles, depth + 1, component.id)
              )}
            </div>
          </SortableContext>
        ) : (
          <div className="absolute inset-0 flex items-center justify-center pointer-events-none opacity-30">
            <div className="text-xs text-gray-400 border-2 border-dashed border-gray-300 rounded p-2">
              Drop here • {component.type}
            </div>
          </div>
        )}
        
        {isSelected && (
          <div className="absolute -top-6 left-0 px-2 py-1 rounded text-xs font-medium bg-blue-500 text-white z-50">
            {component.name} • {component.children?.length || 0} children • Depth {depth}
          </div>
        )}
      </motion.div>
    );

    // ⭐ WRAP in sortable wrapper
    return (
      <SortableComponentWrapper
        key={component.id}
        component={component}
        index={index}
        depth={depth}
        parentId={parentId}
        selectedComponent={selectedComponent}
        onComponentClick={onComponentClick}
        overId={overId}
      >
        {layoutContent}
      </SortableComponentWrapper>
    );
  }
  
  // NON-LAYOUT (keep your existing rendering logic)
  const componentRenderer = componentLibraryService?.getComponent(component.type);
  let renderedContent = null;
  
  if (componentRenderer?.render) {
    try {
      const mergedProps = {
        ...component.props,
        style: component.style
      };
      renderedContent = componentRenderer.render(mergedProps, component.id);
    } catch (error) {
      console.warn('Render error:', error);
      renderedContent = <div className="p-2 border rounded">{component.name}</div>;
    }
  }
  
  const nonLayoutContent = (
    <motion.div
      key={component.id}
      style={componentStyles}
      data-component-id={component.id}
      data-depth={depth}
      data-is-layout="false"
      data-parent-id={parentId || 'root'}
      className={`
        relative 
        ${isSelected ? 'ring-2 ring-blue-500' : ''}
      `}
      onClick={(e) => {
        e.stopPropagation();
        onComponentClick(component.id, e);
      }}
      initial={{ opacity: 0, scale: 0.95 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.95 }}
      transition={{ duration: 0.15 }}
    >
      {renderedContent}
      
      {isSelected && (
        <div className="absolute -top-6 left-0 px-2 py-1 rounded text-xs font-medium bg-blue-500 text-white z-50">
          {component.name} • Depth {depth}
        </div>
      )}
    </motion.div>
  );

  // ⭐ WRAP in sortable wrapper
  return (
    <SortableComponentWrapper
      key={component.id}
      component={component}
      index={index}
      depth={depth}
      parentId={parentId}
      selectedComponent={selectedComponent}
      onComponentClick={onComponentClick}
      overId={overId}
    >
      {nonLayoutContent}
    </SortableComponentWrapper>
  );
}, [componentLibraryService, selectedComponent, onComponentClick, overId]);

  

  
    // FIXED reorderWithinContainer helper
  const reorderWithinContainer = (components, containerId, sourceIndex, destIndex) => {
    console.log('Reordering in container:', containerId, 'from', sourceIndex, 'to', destIndex);
    
    const reorder = (comps) => {
      return comps.map(comp => {
        if (comp.id === containerId) {
          const children = Array.from(comp.children || []);
          const [moved] = children.splice(sourceIndex, 1);
          children.splice(destIndex, 0, moved);
          
          console.log('Reordered children:', children.map(c => c.id));
          
          return {
            ...comp,
            children: children.map((child, idx) => ({
              ...child,
              sortOrder: idx,
              zIndex: idx
            }))
          };
        }
        
        if (comp.children?.length > 0) {
          return {
            ...comp,
            children: reorder(comp.children)
          };
        }
        
        return comp;
      });
    };
    
    return reorder(components);
  };
  
  
  
  
  const moveBetweenContainers = (components, componentId, sourceContainerId, destContainerId, sourceIndex, destIndex) => {
    console.log('Moving between containers:', { componentId, sourceContainerId, destContainerId });
    
    let movedComponent = null;
    
    // Remove from source
    const removeFromSource = (comps) => {
      if (sourceContainerId === null) {
        // Remove from root
        [movedComponent] = comps.splice(sourceIndex, 1);
        return comps;
      }
      
      return comps.map(comp => {
        if (comp.id === sourceContainerId) {
          const children = Array.from(comp.children || []);
          [movedComponent] = children.splice(sourceIndex, 1);
          return { ...comp, children };
        }
        
        if (comp.children?.length > 0) {
          return { ...comp, children: removeFromSource(comp.children) };
        }
        
        return comp;
      });
    };
    
    let withoutMoved = removeFromSource(components);
    
    if (!movedComponent) {
      console.error('Could not find component to move:', componentId);
      return components;
    }
    
    console.log('Moved component:', movedComponent.id);
    
    // Add to destination
    const addToDestination = (comps) => {
      if (destContainerId === null) {
        // Add to root
        comps.splice(destIndex, 0, movedComponent);
        return comps;
      }
      
      return comps.map(comp => {
        if (comp.id === destContainerId) {
          const children = Array.from(comp.children || []);
          children.splice(destIndex, 0, movedComponent);
          return { ...comp, children };
        }
        
        if (comp.children?.length > 0) {
          return { ...comp, children: addToDestination(comp.children) };
        }
        
        return comp;
      });
    };
    
    return addToDestination(withoutMoved);
  };

  // Helper functions for default styling
  const getDefaultDisplay = (componentType) => {
    const displayMap = {
      'nav': 'flex',
      'header': 'block',
      'main': 'block',
      'section': 'block',
      'footer': 'block',
      'div': 'block',
      'article': 'block',
      'aside': 'block',
      'h1': 'block',
      'h2': 'block',
      'h3': 'block',
      'h4': 'block',
      'h5': 'block',
      'h6': 'block',
      'p': 'block',
      'span': 'inline',
      'a': 'inline',
      'button': 'inline-flex',
      'input': 'block',
      'textarea': 'block',
      'img': 'block',
      'video': 'block',
      'iframe': 'block'
    };
    return displayMap[componentType] || 'block';
  };

  const getDefaultWidth = (componentType) => {
    const widthMap = {
      'section': '100%',
      'header': '100%',
      'main': '100%',
      'footer': '100%',
      'nav': '100%',
      'div': '100%',
      'article': '100%',
      'aside': '300px',
      'button': 'fit-content',
      'input': '100%',
      'textarea': '100%'
    };
    return widthMap[componentType] || 'auto';
  };

  const getDefaultMinHeight = (componentType) => {
    const minHeightMap = {
      'section': '200px',
      'header': '80px',
      'main': '400px',
      'footer': '120px',
      'nav': '60px',
      'div': '50px',
      'article': '200px',
      'aside': '200px',
      'button': '40px',
      'input': '40px',
      'textarea': '80px'
    };
    return minHeightMap[componentType] || 'auto';
  };

  const getDefaultMaxWidth = (componentType) => {
    const maxWidthMap = {
      'button': '300px',
      'input': '500px',
      'textarea': '600px',
      'badge': '200px',
      'avatar': '200px'
    };
    return maxWidthMap[componentType] || 'none';
  };

  const getDefaultPadding = (componentType) => {
    const paddingMap = {
      'section': '48px 24px',
      'header': '24px',
      'main': '48px 24px',
      'footer': '32px 24px',
      'nav': '0 24px',
      'div': '24px',
      'article': '32px',
      'aside': '24px',
      'button': '12px 24px',
      'input': '12px 16px',
      'textarea': '12px 16px'
    };
    return paddingMap[componentType] || '0';
  };

  // Quick action buttons for selected component
  const renderComponentActions = useCallback((component) => {
    if (selectedComponent !== component.id) return null;

    return (
      <div className="absolute -top-8 right-0 flex gap-1 z-20">
        <button
          onClick={(e) => {
            e.stopPropagation();
            onPropertyUpdate(component.id, 'reset');
          }}
          className="w-6 h-6 rounded flex items-center justify-center hover:opacity-80 transition-opacity"
          style={{ 
            backgroundColor: 'var(--color-surface)',
            border: '1px solid var(--color-border)',
            color: 'var(--color-text)'
          }}
          title="Reset styles"
        >
          <RotateCcw className="w-3 h-3" />
        </button>
        
        <button
          onClick={(e) => {
            e.stopPropagation();
            const newComponent = {
              ...component,
              id: `${component.type}_${Date.now()}`,
              position: { x: component.position.x + 20, y: component.position.y + 20 }
            };
            // Handle duplication
          }}
          className="w-6 h-6 rounded flex items-center justify-center hover:opacity-80 transition-opacity"
          style={{ 
            backgroundColor: 'var(--color-surface)',
            border: '1px solid var(--color-border)',
            color: 'var(--color-text)'
          }}
          title="Duplicate"
        >
          <Square className="w-3 h-3" />
        </button>
      </div>
    );
  }, [selectedComponent, onPropertyUpdate]);

  return (
    <div className="w-full max-w-none flex justify-center" style={{ backgroundColor: 'transparent' }}>
      {/* Responsive Canvas Container */}
      <div
        className={`
          relative transition-all duration-500 ease-in-out overflow-visible
          ${isFrameSwitching ? 'opacity-50 scale-95' : 'opacity-100 scale-100'}
          ${responsiveMode !== 'desktop' ? 'shadow-2xl' : ''}
        `}
        style={{ 
          width: canvasSize.width,
          maxWidth: canvasSize.maxWidth,
          transform: `scale(${scaleFactor})`,
          transformOrigin: 'center top'
        }}
      >
        {/* Device-Specific Browser Frame */}
        {responsiveMode === 'desktop' && (
          /* MacBook-Style Browser Tab Frame */
          <div 
            className="relative mb-0 rounded-t-xl overflow-hidden pointer-events-none"
            style={{
              backgroundColor: '#f5f5f7',
              border: '1px solid #d1d5db',
              borderBottom: 'none'
            }}
          >
            {/* Tab Bar */}
            <div 
              className="flex items-center px-4 py-2 border-b"
              style={{ 
                backgroundColor: '#e5e7eb',
                borderBottomColor: '#d1d5db'
              }}
            >
              {/* Traffic Light Buttons */}
              <div className="flex items-center gap-2 mr-4">
                <div className="w-3 h-3 rounded-full bg-red-500"></div>
                <div className="w-3 h-3 rounded-full bg-yellow-500"></div>
                <div className="w-3 h-3 rounded-full bg-green-500"></div>
              </div>
              
              {/* Active Tab */}
              <div 
                className="flex items-center gap-2 px-4 py-1 rounded-t-lg relative"
                style={{ 
                  backgroundColor: 'var(--color-surface)',
                  border: '1px solid #d1d5db',
                  borderBottom: 'none',
                  minWidth: '200px'
                }}
              >
                {/* Tab Favicon */}
                <div className="w-4 h-4 rounded-sm flex items-center justify-center text-xs font-bold" style={{ backgroundColor: 'var(--color-primary)', color: 'white' }}>
                  D
                </div>
                
                {/* Tab Title */}
                <span className="text-sm font-medium flex-1 truncate" style={{ color: 'var(--color-text)' }}>
                  DeCode - {currentFrame} ({responsiveMode})
                </span>
                
                {/* Tab Close Button */}
                <div className="w-4 h-4 rounded-sm flex items-center justify-center">
                  <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </div>
              </div>
              
              {/* New Tab Button */}
              <div className="ml-2 w-8 h-8 rounded-lg flex items-center justify-center">
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" />
                </svg>
              </div>
              
              {/* Browser Controls */}
              <div className="ml-auto flex items-center gap-2">
                <div className="flex items-center gap-1">
                  <div className="w-6 h-6 rounded flex items-center justify-center">
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 19l-7-7 7-7" />
                    </svg>
                  </div>
                  <div className="w-6 h-6 rounded flex items-center justify-center">
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7" />
                    </svg>
                  </div>
                  <div className="w-6 h-6 rounded flex items-center justify-center">
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                  </div>
                </div>
              </div>
            </div>
            
            {/* Address Bar */}
            <div className="flex items-center px-4 py-2 gap-3">
              {/* Security Icon */}
              <div className="flex items-center gap-1">
                <svg className="w-4 h-4 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
                </svg>
              </div>
              
              {/* Address Bar Input */}
              <div 
                className="flex-1 px-3 py-1 rounded-md text-sm flex items-center gap-2"
                style={{ 
                  backgroundColor: 'white',
                  border: '1px solid #d1d5db',
                  color: '#6b7280'
                }}
              >
                <span>https://</span>
                <span style={{ color: 'var(--color-text)' }}>decode.app/forge/{currentFrame}</span>
                <div className="ml-auto flex items-center gap-1">
                  <svg className="w-4 h-4 text-yellow-500" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                  </svg>
                </div>
              </div>
              
              {/* Profile Avatar */}
              <div className="w-6 h-6 rounded-full overflow-hidden">
                <div className="w-full h-full flex items-center justify-center text-xs font-bold text-white" style={{ backgroundColor: 'var(--color-primary)' }}>
                  U
                </div>
              </div>
            </div>
          </div>
        )}

        {responsiveMode === 'tablet' && (
          /* iPad-Style Safari Frame */
          <div 
            className="relative mb-0 rounded-t-2xl overflow-hidden pointer-events-none"
            style={{
              backgroundColor: '#f2f2f7',
              border: '1px solid #d1d5db',
              borderBottom: 'none'
            }}
          >
            {/* Safari Address Bar */}
            <div 
              className="flex items-center px-4 py-3 gap-3"
              style={{ 
                backgroundColor: '#ffffff',
                borderBottomColor: '#d1d5db'
              }}
            >
              {/* Navigation Buttons */}
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 rounded-full bg-gray-100 flex items-center justify-center">
                  <svg className="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 19l-7-7 7-7" />
                  </svg>
                </div>
                <div className="w-8 h-8 rounded-full bg-gray-100 flex items-center justify-center">
                  <svg className="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7" />
                  </svg>
                </div>
              </div>
              
              {/* Address Bar */}
              <div 
                className="flex-1 mx-4 px-4 py-2 rounded-full text-sm flex items-center gap-2"
                style={{ 
                  backgroundColor: '#f2f2f7',
                  border: '1px solid #e5e5ea'
                }}
              >
                <svg className="w-4 h-4 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
                </svg>
                <span style={{ color: 'var(--color-text)' }}>decode.app/forge/{currentFrame}</span>
                <div className="ml-auto">
                  <svg className="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                </div>
              </div>
              
              {/* Share Button */}
              <div className="w-8 h-8 rounded-full bg-gray-100 flex items-center justify-center">
                <svg className="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z" />
                </svg>
              </div>
            </div>
          </div>
        )}

        {responsiveMode === 'mobile' && (
          /* iPhone-Style Safari Frame */
          <div 
            className="relative mb-0 overflow-hidden pointer-events-none"
            style={{
              backgroundColor: '#f2f2f7',
              borderTopLeftRadius: '1rem',
              borderTopRightRadius: '1rem',
              border: '1px solid #d1d5db',
              borderBottom: 'none'
            }}
          >
            {/* Safari Address Bar */}
            <div 
              className="flex items-center px-3 py-2 gap-2"
              style={{ 
                backgroundColor: '#ffffff'
              }}
            >
              {/* Address Bar Input */}
              <div 
                className="flex-1 px-3 py-1.5 rounded-full text-sm flex items-center gap-2"
                style={{ 
                  backgroundColor: '#f2f2f7',
                  border: '1px solid #e5e5ea'
                }}
              >
                <svg className="w-3 h-3 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
                </svg>
                <span className="text-xs truncate" style={{ color: 'var(--color-text)' }}>decode.app</span>
                <div className="ml-auto">
                  <svg className="w-3 h-3 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                </div>
              </div>
              
              {/* Menu Button */}
              <div className="w-6 h-6 rounded flex items-center justify-center">
                <svg className="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z" />
                </svg>
              </div>
            </div>
          </div>
        )}
        {/* Device Frame for Mobile/Tablet */}
        {responsiveMode !== 'desktop' && (
          <div 
            className="absolute -inset-4 rounded-[2rem] shadow-2xl border-8 pointer-events-none"
            style={{ 
              borderColor: '#1f2937',
              backgroundColor: '#111827'
            }}
          >
            {/* Device notch for mobile */}
            {responsiveMode === 'mobile' && (
              <div 
                className="absolute top-0 left-1/2 transform -translate-x-1/2 w-32 h-6 rounded-b-xl"
                style={{ backgroundColor: '#111827' }}
              />
            )}
            
            {/* Device info label */}
            <div className="absolute -bottom-12 left-1/2 transform -translate-x-1/2">
              <div 
                className="px-3 py-1 rounded-full text-xs flex items-center gap-2 font-medium"
                style={{ 
                  backgroundColor: 'var(--color-surface)',
                  color: 'var(--color-text)',
                  border: '1px solid var(--color-border)'
                }}
              >
                {responsiveMode === 'mobile' ? <Smartphone className="w-3 h-3" /> : <Tablet className="w-3 h-3" />}
                {canvasSize.deviceName} ({canvasSize.width}px)
                {zoomLevel !== 100 && <span>• {zoomLevel}%</span>}
              </div>
            </div>

            {/* Mobile/Tablet Browser Tabs at top of device frame */}
            {responsiveMode === 'tablet' && (
              <div 
                className="absolute -top-8 left-1/2 transform -translate-x-1/2 flex items-center gap-1"
                style={{ width: 'calc(100% - 32px)' }}
              >
                {/* Tab 1 - Active */}
                <div 
                  className="flex-1 h-6 rounded-t-lg flex items-center px-2 gap-1 max-w-[120px]"
                  style={{ 
                    backgroundColor: 'var(--color-surface)',
                    border: '1px solid var(--color-border)',
                    borderBottom: 'none'
                  }}
                >
                  <div className="w-2 h-2 rounded-full" style={{ backgroundColor: 'var(--color-primary)' }}></div>
                  <span className="text-[8px] truncate" style={{ color: 'var(--color-text)' }}>DeCode</span>
                </div>
                
                {/* Tab 2 - Inactive */}
                <div 
                  className="w-8 h-5 rounded-t-lg flex items-center justify-center"
                  style={{ 
                    backgroundColor: '#e5e7eb',
                    border: '1px solid #d1d5db',
                    borderBottom: 'none'
                  }}
                >
                  <div className="w-1.5 h-1.5 rounded-full bg-gray-400"></div>
                </div>
                
                {/* New Tab Button */}
                <div 
                  className="w-6 h-5 rounded-t-lg flex items-center justify-center"
                  style={{ backgroundColor: '#f3f4f6' }}
                >
                  <svg className="w-2 h-2 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M12 4v16m8-8H4" />
                  </svg>
                </div>
              </div>
            )}

            {responsiveMode === 'mobile' && (
              <div 
                className="absolute -top-6 left-1/2 transform -translate-x-1/2 flex items-center gap-0.5"
                style={{ width: 'calc(100% - 24px)' }}
              >
                {/* Active Tab */}
                <div 
                  className="flex-1 h-4 rounded-t-md flex items-center px-1.5 gap-1 max-w-[80px]"
                  style={{ 
                    backgroundColor: 'var(--color-surface)',
                    border: '1px solid var(--color-border)',
                    borderBottom: 'none'
                  }}
                >
                  <div className="w-1.5 h-1.5 rounded-full" style={{ backgroundColor: 'var(--color-primary)' }}></div>
                  <span className="text-[6px] truncate" style={{ color: 'var(--color-text)' }}>DeCode</span>
                </div>
                
                {/* Inactive Tab */}
                <div 
                  className="w-6 h-3 rounded-t-md flex items-center justify-center"
                  style={{ 
                    backgroundColor: '#e5e7eb',
                    border: '1px solid #d1d5db',
                    borderBottom: 'none'
                  }}
                >
                  <div className="w-1 h-1 rounded-full bg-gray-400"></div>
                </div>

                {/* New Tab Button */}
                <div 
                  className="w-5 h-3 rounded-t-md flex items-center justify-center"
                  style={{ backgroundColor: '#f3f4f6' }}
                >
                  <svg className="w-1.5 h-1.5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="4" d="M12 4v16m8-8H4" />
                  </svg>
                </div>
              </div>
            )}
          </div>
        )}

        {/* Main Canvas - Acts as Document Body */}
          <div 
              ref={canvasRef}
              className={`
                  relative transition-all duration-500
                  ${canvasClasses}
                  ${isFrameSwitching ? 'opacity-50 pointer-events-none' : ''}
              `}
              style={{
                  width: '100%',
                  minHeight: responsiveMode === 'desktop' ? '100vh' : '667px',
                  height: responsiveMode === 'desktop' ? 'auto' : `${canvasSize.height}px`,
                  maxWidth: canvasSize.maxWidth,
                  backgroundColor: 'var(--color-surface)',
                  fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                  lineHeight: '1.6',
                  color: 'var(--color-text)',
                  cursor: dragState.isDragging ? 'copy' : 'default',
                  borderRadius: responsiveMode !== 'desktop' ? '1rem' : '0',
                  boxShadow: responsiveMode !== 'desktop' ? 'inset 0 0 0 1px rgba(0,0,0,0.1)' : 'none',
                  position: 'relative',
                  overflow: 'auto' // CRITICAL: Enable scrolling
              }}
              onDragOver={onCanvasDragOver}
              onDrop={onCanvasDrop}
              onClick={onCanvasClick}
          >
          {/* Canvas Grid Background - Only show if enabled */}
          {gridVisible && (
            <div 
              className="absolute inset-0 pointer-events-none opacity-20 z-0"
              style={{
                backgroundImage: `
                  linear-gradient(to right, var(--color-border) 1px, transparent 1px),
                  linear-gradient(to bottom, var(--color-border) 1px, transparent 1px)
                `,
                backgroundSize: '20px 20px'
              }}
            />
          )}
          
          
          {/* ADD HERE - Drag Snap Lines */}
          {DragSnapLines && dragPosition && dragState.isDragging && (
            <DragSnapLines
              dragPosition={dragPosition}
              canvasComponents={canvasComponents}
              canvasRef={canvasRef}
            />
          )}
          
          {/* ADD HERE - Selection Overlay for selected component */}
          {SelectionOverlay && selectedComponent && selectedComponent !== '__canvas_root__' && (
            <SelectionOverlay
              componentId={selectedComponent}
              canvasRef={canvasRef}
            />
          )}
                    
          
         {/* Drop Zone Indicator - ONLY show when canvas is empty */}
        {dragState.isDragging && canvasComponents.length === 0 && (
          <div 
            className="absolute inset-0 border-4 border-dashed flex items-center justify-center z-50"
            style={{ 
              borderColor: 'var(--color-primary)',
              backgroundColor: 'rgba(160, 82, 255, 0.05)',
              backdropFilter: 'blur(2px)',
              borderRadius: responsiveMode !== 'desktop' ? '1rem' : '0'
            }}
          >
            <div 
              className="font-medium text-lg px-6 py-3 rounded-xl"
              style={{ 
                color: 'var(--color-primary)',
                backgroundColor: 'var(--color-surface)',
                border: '2px solid var(--color-primary)',
                boxShadow: 'var(--shadow-lg)'
              }}
            >
              Drop {dragState.draggedComponent?.name || 'component'} here
            </div>
          </div>
        )}

      {/* Render Components with Drag-to-Reorder */}
      <div className="relative z-10" style={{ minHeight: '100%' }}>
        {canvasComponents.length === 0 && !dragState.isDragging ? (
          <EmptyCanvasState
            frameType={frameType}
            onAddSection={() => {
              const sectionComponent = componentLibraryService?.createLayoutElement('section');
              if (sectionComponent && onPropertyUpdate) {
                onPropertyUpdate('canvas', [...canvasComponents, sectionComponent]);
              }
            }}
            onDragOver={onCanvasDragOver}
            onDrop={onCanvasDrop}
            isDragOver={dragState.isDragging}
            responsiveMode={responsiveMode}
          />
        ) : (
                   <DndContext
            sensors={sensors}
            collisionDetection={closestCenter}
            onDragStart={handleDndDragStart}
            onDragOver={handleDndDragOver}
            onDragEnd={handleDndDragEnd}
            onDragCancel={handleDndDragCancel}
          >
            <SortableContext 
              items={canvasComponents.map(c => c.id)}
              strategy={verticalListSortingStrategy}
            >
              <AnimatePresence mode="popLayout">
                {canvasComponents.map((component, index) => 
                  renderComponent(component, index, {}, 0)
                )}
              </AnimatePresence>
            </SortableContext>
          
            {/* Drag Overlay - ACTUAL COMPONENT UI FOLLOWING FINGER */}
            <DragOverlay
              dropAnimation={{
                duration: 250,
                easing: 'cubic-bezier(0.18, 0.67, 0.6, 1.22)',
              }}
              style={{ cursor: 'grabbing' }}
            >
              {draggedComponent && (
                <motion.div
                  initial={{ scale: 1, rotate: 0 }}
                  animate={{ 
                    scale: 1.05, 
                    rotate: 3,
                    boxShadow: '0 20px 60px rgba(0,0,0,0.3)'
                  }}
                  transition={{ duration: 0.2 }}
                  className="bg-white/95 backdrop-blur-xl rounded-lg shadow-2xl border-2 border-purple-500 overflow-hidden"
                  style={{
                    pointerEvents: 'none',
                    transformOrigin: 'center center'
                  }}
                >
                  {/* Render the ACTUAL component UI */}
                  {(() => {
                    const componentRenderer = componentLibraryService?.getComponent(draggedComponent.type);
                    if (componentRenderer?.render) {
                      try {
                        return componentRenderer.render({
                          ...draggedComponent.props,
                          style: draggedComponent.style
                        }, draggedComponent.id);
                      } catch (e) {
                        return (
                          <div className="p-4 text-center">
                            <div className="font-semibold">{draggedComponent.name}</div>
                            <div className="text-xs text-gray-500">{draggedComponent.type}</div>
                          </div>
                        );
                      }
                    }
                    return (
                      <div className="p-4 text-center">
                        <div className="font-semibold">{draggedComponent.name}</div>
                        <div className="text-xs text-gray-500">{draggedComponent.type}</div>
                      </div>
                    );
                  })()}
                </motion.div>
              )}
            </DragOverlay>
          </DndContext>
        )}
      </div>

      {/* Status Bar - Only for Desktop */}
      {responsiveMode === 'desktop' && canvasComponents.length > 0 && (
        <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2">
          <div 
            className="inline-flex items-center gap-4 text-sm px-4 py-2 rounded-full shadow-lg backdrop-blur-sm"
            style={{ 
              color: 'var(--color-text-muted)',
              backgroundColor: 'rgba(255, 255, 255, 0.9)',
              border: '1px solid var(--color-border)'
            }}
          >
            <span>{canvasComponents.length} components</span>
            {selectedComponent && (
              <span style={{ color: 'var(--color-primary)' }}>
                {canvasComponents.find(c => c.id === selectedComponent)?.name || 'Selected'} 
                • {canvasComponents.find(c => c.id === selectedComponent)?.style?.display || 'block'}
              </span>
            )}
            <span style={{ color: 'var(--color-border)' }}>|</span>
            <span>{canvasSize.deviceName}</span>
          </div>
        </div>
      )}
    </div>
    </div>
    </div>
  );
};

export default CanvasComponent;



// Enhanced ForgePage.jsx - Frame Switching with Smooth Transitions
import React, { useState, useRef, useCallback, useEffect, useMemo } from 'react'
import AuthenticatedLayout from '@/Layouts/AuthenticatedLayout';
import { Head, router } from '@inertiajs/react';
import Panel from '@/Components/Panel';
import { 
  Square, Code, Layers, User, Settings, ChevronUp, ChevronDown, Copy, RefreshCw, 
  Monitor, PictureInPicture, Loader2, ChevronRight  // ADD ChevronRight
} from 'lucide-react';
import { useForgeStore } from '@/stores/useForgeStore';
import { useEditorStore } from '@/stores/useEditorStore';
import { useForgeUndoRedoStore } from '@/stores/useForgeUndoRedoStore';
import { useCodeSyncStore } from '@/stores/useCodeSyncStore';
import { useThumbnail } from '@/hooks/useThumbnail';

// Import separated forge components
import ComponentsPanel from '@/Components/Forge/ComponentsPanel';
import LayersPanel from '@/Components/Forge/LayersPanel';
import PropertiesPanel from '@/Components/Forge/PropertiesPanel';
import AssetsPanel from '@/Components/Forge/AssetsPanel';
import CanvasComponent from '@/Components/Forge/CanvasComponent';
import BottomCodePanel from '@/Components/Forge/BottomCodePanel';
import SidebarCodePanel from '@/Components/Forge/SidebarCodePanel';
import ModalCodePanel from '@/Components/Forge/ModalCodePanel';

import CodeTooltip from '@/Components/Forge/CodeTooltip';
import FloatingFrameSwitcher from '@/Components/Forge/FloatingFrameSwitcher';
import WindowPanel from '@/Components/WindowPanel';
import LayoutPresets from '@/Components/Forge/LayoutPresets';
import EmptyCanvasState from '@/Components/Forge/EmptyCanvasState';
import SectionDropZone from '@/Components/Forge/SectionDropZone';
import IconWindowPanel from '@/Components/Forge/IconWindowPanel';



import ErrorBoundary from '@/Components/ErrorBoundary';

// Import dynamic component service
import { componentLibraryService } from '@/Services/ComponentLibraryService';
import { tooltipDatabase } from '@/Components/Forge/TooltipDatabase';
import { formatCode, highlightCode, parseCodeAndUpdateComponents } from '@/Components/Forge/CodeUtils';






// ADD THIS HELPER FUNCTION BEFORE export default function ForgePage:
const safeLeaveChannel = (channelName) => {
  if (!window.Echo) {
    console.warn('Echo not available');
    return;
  }

  try {
    // Get the channel from Echo's connector
    const channels = window.Echo.connector?.channels || {};
    const channel = channels[channelName];

    if (channel && typeof channel.leave === 'function') {
      console.log('Leaving channel:', channelName);
      channel.leave();
    } else if (window.Echo.leave) {
      console.log('Using Echo.leave for:', channelName);
      window.Echo.leave(channelName);
    } else {
      console.warn('Cannot leave channel (not joined):', channelName);
    }
  } catch (error) {
    console.error('Error leaving channel:', channelName, error);
    // Don't throw - just log and continue
  }
};







export default function ForgePage({ 
  projectId, 
  frameId, 
  project, 
  frame, 
  projectFrames = []
}) {
  // Zustand stores with proper subscriptions
  const {
    toggleForgePanel,
    isForgePanelOpen,
    getOpenForgePanelsCount,
    allPanelsHidden,
    forgePanelStates,
    _triggerUpdate
  } = useForgeStore()
  
  const {
    responsiveMode,
    getCurrentCanvasDimensions,
    getResponsiveDeviceInfo,
    getResponsiveScaleFactor,
    getResponsiveCanvasClasses,
    getResponsiveGridBackground,
    gridVisible,
    zoomLevel
  } = useEditorStore();
  
  const {
    initializeFrame: initUndoRedoFrame,
    pushHistory,
    scheduleAutoSave,
    actionTypes,
    undo,
    redo,
    canUndo,
    canRedo
  } = useForgeUndoRedoStore();
  
  const { 
    syncedCode,         
    codeStyle,            
    setCodeStyle: setSyncedCodeStyle,
    updateSyncedCode 
  } = useCodeSyncStore();

  // Frame switching state
  const [isFrameSwitching, setIsFrameSwitching] = useState(false)
  const [switchingToFrame, setSwitchingToFrame] = useState(null)
  const [frameTransitionPhase, setFrameTransitionPhase] = useState('idle') // 'idle', 'fadeOut', 'loading', 'fadeIn'

  // Mobile detection
  const [isMobile, setIsMobile] = useState(false)
  const [windowDimensions, setWindowDimensions] = useState({ width: 0, height: 0 })
  
  
  // Add these states near your other useState declarations
  const [dragPosition, setDragPosition] = useState(null);
  const [isCanvasSelected, setIsCanvasSelected] = useState(false);

  // Canvas state for dropped components - Now frame-specific
  const [frameCanvasComponents, setFrameCanvasComponents] = useState(() => {
      const initialFrameData = {};
      const currentFrameId = frameId || frame?.uuid;
      
      console.log('ForgePage: Initializing frame data for:', currentFrameId);
      console.log('ForgePage: Frame prop data:', frame?.canvas_data);
      
      if (currentFrameId) {
          // Check if we have backend data in frame.canvas_data.components
          if (frame?.canvas_data?.components && Array.isArray(frame.canvas_data.components)) {
              console.log('ForgePage: Loading', frame.canvas_data.components.length, 'components from backend');
              initialFrameData[currentFrameId] = frame.canvas_data.components;
          } else {
              // Initialize empty array for this frame
              console.log('ForgePage: No backend components, initializing empty array');
              initialFrameData[currentFrameId] = [];
          }
      }
      
      return initialFrameData;
  });
  const [selectedComponent, setSelectedComponent] = useState(null)
  const [generatedCode, setGeneratedCode] = useState({ html: '', css: '', react: '', tailwind: '' })
  
  const showCodePanel = isForgePanelOpen('code-panel');
  
  const [codePanelPosition, setCodePanelPosition] = useState('bottom')
  const [activeCodeTab, setActiveCodeTab] = useState('react')
  const [showTooltips, setShowTooltips] = useState(true)
  const [hoveredToken, setHoveredToken] = useState(null)
  
  // Mobile-optimized code panel settings
  const [codePanelHeight, setCodePanelHeight] = useState(400)
  const [codePanelMinimized, setCodePanelMinimized] = useState(false)
  const [componentsLoaded, setComponentsLoaded] = useState(false)
  const [loadingMessage, setLoadingMessage] = useState('Initializing components...')

  // Component panel tab state
  const [activeComponentTab, setActiveComponentTab] = useState('elements')
  const [componentSearchTerm, setComponentSearchTerm] = useState('')
  
  const [undoRedoInProgress, setUndoRedoInProgress] = useState(false);
  
  // ADD these state variables for drag reordering
  const [draggedItem, setDraggedItem] = useState(null);
  const [dragOverItem, setDragOverItem] = useState(null);
  const [dragOverContainer, setDragOverContainer] = useState(null);

  // Enhanced drag state with variant support
  const [dragState, setDragState] = useState({
    isDragging: false,
    draggedComponent: null,
    dragPreview: null,
    variant: null
  })

  // WindowPanel state
  const [windowPanelState, setWindowPanelState] = useState({
    isOpen: false,
    mode: 'modal',
    title: 'Forge Window',
    position: { x: 100, y: 100 },
    size: { width: 600, height: 400 }
  })
  
  const {
    scheduleCanvasUpdate: scheduleThumbnailUpdate,
    isGenerating: thumbnailGenerating,
    thumbnailUrl,
    generateFromCanvas: generateThumbnailFromCanvas
  } = useThumbnail(frame?.uuid, frame?.type || 'page', {
    enableRealTimeUpdates: true,
    debounceMs: 2000 // 2 second debounce for canvas updates
  });

  const canvasRef = useRef(null)
  const codePanelRef = useRef(null)
  
  const [currentFrame, setCurrentFrame] = useState(() => {
      const frameIdToUse = frameId || frame?.uuid;
      console.log('ForgePage: Initial frame ID:', frameIdToUse);
      return frameIdToUse;
  });
  
  
  
  
  // In ForgePage.jsx - REPLACE your existing useEffect for Echo cleanup

useEffect(() => {
  const currentFrameRef = frameId || frame?.uuid;
  
  return () => {
    console.log('ForgePage: Component unmounting');
    
    // The store will handle cleanup via navigation listeners
    // But we still cleanup on unmount as a safety measure
    if (currentFrameRef) {
      useFramePresenceStore.getState().cleanupFrame(currentFrameRef);
    }
  };
}, [frameId, frame?.uuid]);
  
  
  
  
  
  
  const getCanvasPadding = () => {
    // Now responsiveMode is accessible from useEditorStore
    const basePadding = responsiveMode === 'desktop' ? 'p-8' : 'p-4';
    
    if (codePanelPosition === 'bottom' && showCodePanel) {
      if (codePanelMinimized) {
        return isMobile ? 'pb-16' : 'pb-20';
      }
      
      const panelHeight = Math.min(codePanelHeight, windowDimensions.height * 0.7);
      return isMobile ? `pb-[${panelHeight + 60}px]` : `pb-[${panelHeight + 80}px]`;
    }
    
    return basePadding;
  };
  
  
  // ADD these at the TOP of ForgePage.jsx, after imports and before the component

const LAYOUT_TYPES = ['section', 'container', 'div', 'flex', 'grid'];
const isLayoutElement = (type) => LAYOUT_TYPES.includes(type);

  // Get current frame's canvas components
  const canvasComponents = frameCanvasComponents[currentFrame] || []



    // MODIFY existing generateCode callback
  const generateCode = useCallback(async (components) => {
    try {
      if (!componentLibraryService || !componentLibraryService.clientSideCodeGeneration) {
        const mockCode = {
          react: `// Generated React Code for Frame: ${currentFrame}\nfunction App() {\n  return (\n    <div>\n      {/* ${components.length} components */}\n    </div>\n  );\n}`,
          html: `<!-- Generated HTML for Frame: ${currentFrame} -->\n<div>\n  <!-- ${components.length} components -->\n</div>`,
          css: `/* Generated CSS for Frame: ${currentFrame} */\n.container {\n  /* Styles for ${components.length} components */\n}`,
          tailwind: `<!-- Generated Tailwind for Frame: ${currentFrame} -->\n<div class="container">\n  <!-- ${components.length} components -->\n</div>`
        };
        setGeneratedCode(mockCode);
        updateSyncedCode(mockCode); // ADD THIS LINE
        return;
      }
  
      const code = await componentLibraryService.clientSideCodeGeneration(components, codeStyle);
      setGeneratedCode(code);
      updateSyncedCode(code); // ADD THIS LINE
      
      console.log('Code generated and synced successfully for frame:', currentFrame, Object.keys(code));
    } catch (error) {
      console.error('Failed to generate code:', error);
      const mockCode = {
        react: `// Error generating code\nfunction App() {\n  return <div>Error</div>;\n}`,
        html: `<!-- Error generating code -->`,
        css: `/* Error generating code */`,
        tailwind: `<!-- Error generating code -->`
      };
      setGeneratedCode(mockCode);
      updateSyncedCode(mockCode); // ADD THIS LINE
    }
  }, [codeStyle, currentFrame, updateSyncedCode]);

 // REPLACE existing setCodeStyle with: 
  const handleCodeStyleChange = useCallback((newStyle) => {
    setSyncedCodeStyle(newStyle);         // ✅ Just use the synced setter
    generateCode(canvasComponents);       // Will use updated codeStyle from store
  }, [canvasComponents, generateCode, setSyncedCodeStyle]);


  
  
  
  
    // Handler: Start dragging an existing component to reorder it
  const handleReorderDragStart = useCallback((e, componentId, parentId = null) => {
    e.stopPropagation();
    
    const component = canvasComponents.find(c => c.id === componentId);
    if (!component) return;
    
    setDraggedItem({ id: componentId, parentId });
    setSelectedComponent(componentId);
    
    // Visual feedback
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', e.currentTarget);
    
    // Add dragging class for styling
    e.currentTarget.classList.add('dragging');
    
    console.log('Started reordering component:', componentId, 'from parent:', parentId);
  }, [canvasComponents]);
  
  // Handler: Dragging over another component (for reorder positioning)
  const handleReorderDragOver = useCallback((e, componentId, parentId = null) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (!draggedItem || draggedItem.id === componentId) return;
    
    setDragOverItem({ id: componentId, parentId });
    setDragOverContainer(parentId);
    
    // Change cursor to indicate drop is allowed
    e.dataTransfer.dropEffect = 'move';
  }, [draggedItem]);
  
  // Handler: Drop component to reorder
  const handleReorderDrop = useCallback((e, targetComponentId, targetParentId = null) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (!draggedItem || draggedItem.id === targetComponentId) {
      setDraggedItem(null);
      setDragOverItem(null);
      setDragOverContainer(null);
      return;
    }
    
    console.log('Reordering:', draggedItem.id, 'relative to:', targetComponentId);
    
    // Deep clone components
    let updatedComponents = JSON.parse(JSON.stringify(canvasComponents));
    
    // Find and remove the dragged component
    let draggedComponent = null;
    
    const removeComponent = (comps, id, parentId) => {
      if (parentId === null) {
        // Root level
        const index = comps.findIndex(c => c.id === id);
        if (index !== -1) {
          draggedComponent = comps.splice(index, 1)[0];
          return true;
        }
      } else {
        // Nested in parent
        for (let comp of comps) {
          if (comp.id === parentId && comp.children) {
            const index = comp.children.findIndex(c => c.id === id);
            if (index !== -1) {
              draggedComponent = comp.children.splice(index, 1)[0];
              return true;
            }
          }
          if (comp.children && removeComponent(comp.children, id, parentId)) {
            return true;
          }
        }
      }
      return false;
    };
    
    removeComponent(updatedComponents, draggedItem.id, draggedItem.parentId);
    
    if (!draggedComponent) {
      console.error('Could not find dragged component');
      setDraggedItem(null);
      setDragOverItem(null);
      return;
    }
    
    // Insert at new position
    const insertComponent = (comps, targetId, targetParent, draggedComp) => {
      if (targetParent === null) {
        // Root level insertion
        const targetIndex = comps.findIndex(c => c.id === targetId);
        if (targetIndex !== -1) {
          comps.splice(targetIndex, 0, draggedComp);
          return true;
        }
      } else {
        // Nested insertion
        for (let comp of comps) {
          if (comp.id === targetParent && comp.children) {
            const targetIndex = comp.children.findIndex(c => c.id === targetId);
            if (targetIndex !== -1) {
              comp.children.splice(targetIndex, 0, draggedComp);
              return true;
            }
          }
          if (comp.children && insertComponent(comp.children, targetId, targetParent, draggedComp)) {
            return true;
          }
        }
      }
      return false;
    };
    
    const inserted = insertComponent(updatedComponents, targetComponentId, targetParentId, draggedComponent);
    
    if (!inserted) {
      console.error('Could not insert component at target position');
      // Revert - add back to original position
      if (draggedItem.parentId === null) {
        updatedComponents.push(draggedComponent);
      }
      setDraggedItem(null);
      setDragOverItem(null);
      return;
    }
    
    // Update sortOrder for all siblings
    const updateSortOrders = (comps) => {
      comps.forEach((comp, index) => {
        comp.sortOrder = index;
        if (comp.children) {
          updateSortOrders(comp.children);
        }
      });
    };
    updateSortOrders(updatedComponents);
    
    // Update state
    setFrameCanvasComponents(prev => ({
      ...prev,
      [currentFrame]: updatedComponents
    }));
    
    pushHistory(currentFrame, updatedComponents, actionTypes.MOVE, {
      componentName: draggedComponent.name,
      componentId: draggedComponent.id,
      fromParent: draggedItem.parentId || 'root',
      toParent: targetParentId || 'root',
      targetComponent: targetComponentId
    });
    
    generateCode(updatedComponents);
    
    // Cleanup
    setDraggedItem(null);
    setDragOverItem(null);
    setDragOverContainer(null);
    
    console.log('Reorder completed successfully');
    
  }, [draggedItem, canvasComponents, currentFrame, pushHistory, actionTypes, generateCode]);
  
  // Handler: Drag end (cleanup)
  const handleReorderDragEnd = useCallback((e) => {
    e.target.classList.remove('dragging');
    setDraggedItem(null);
    setDragOverItem(null);
    setDragOverContainer(null);
  }, []);
  
  
  
  
  

  
  
    // ADD: Detect if project is GitHub import
  const [isGitHubProject, setIsGitHubProject] = useState(false);
  const [gitHubRepo, setGitHubRepo] = useState(null);
  
  useEffect(() => {
    if (project?.settings?.imported_from_github) {
      setIsGitHubProject(true);
      setGitHubRepo(project.settings.original_repo);
    }
  }, [project]);
  
  
  
  // Load components lazily after mount
useEffect(() => {
  const loadFrameComponents = async () => {
    if (!currentFrame || !projectId) return;
    
    try {
      const response = await axios.get(`/api/frames/${currentFrame}/components`);
      if (response.data.success) {
        setFrameCanvasComponents(prev => ({
          ...prev,
          [currentFrame]: response.data.data
        }));
        
        if (response.data.data.length > 0) {
          generateCode(response.data.data);
        }
      }
    } catch (error) {
      console.error('Failed to load frame components:', error);
    }
  };
  
  // Delay loading slightly to allow page to render first
  const timeoutId = setTimeout(loadFrameComponents, 100);
  return () => clearTimeout(timeoutId);
}, [currentFrame, projectId]);
  
  
  
  
  // ADD: GitHub sync handler
  const handleGitHubSync = useCallback(async () => {
    if (!isGitHubProject || !projectId) return;
    
    try {
      const response = await axios.post(`/api/github/projects/${projectId}/sync`);
      if (response.data.success) {
        // Refresh frame data after sync
        router.reload({ only: ['frame', 'project'] });
      }
    } catch (error) {
      console.error('GitHub sync failed:', error);
    }
  }, [isGitHubProject, projectId]);
  
 
  
   // MODIFY your frame data initialization to be more robust
  useEffect(() => {
    console.log('ForgePage: Frame props changed:', { 
      frameId, 
      frameUuid: frame?.uuid, 
      hasCanvasData: !!frame?.canvas_data,
      componentCount: frame?.canvas_data?.components?.length || 0
    });
    
    const currentFrameId = frameId || frame?.uuid;
    
    if (!currentFrameId) {
      console.warn('ForgePage: No frame ID available');
      return;
    }
    
    if (currentFrameId !== currentFrame) {
      console.log('ForgePage: Updating current frame from', currentFrame, 'to', currentFrameId);
      setCurrentFrame(currentFrameId);
      setSelectedComponent(null);
      
      // CRITICAL: Always initialize frame data to prevent blank state
      if (frame?.canvas_data?.components && Array.isArray(frame.canvas_data.components)) {
        console.log('ForgePage: Loading frame components from backend:', frame.canvas_data.components.length);
        setFrameCanvasComponents(prev => ({
          ...prev,
          [currentFrameId]: frame.canvas_data.components
        }));
        
        if (frame.canvas_data.components.length > 0) {
          generateCode(frame.canvas_data.components);
        }
      } else {
        // Initialize empty array to prevent undefined errors
        console.log('ForgePage: Initializing empty frame data');
        setFrameCanvasComponents(prev => ({
          ...prev,
          [currentFrameId]: []
        }));
        generateCode([]);
      }
    }
  }, [frameId, frame?.uuid, frame?.canvas_data, currentFrame]);
  


  // Mock project frames data - This should come from your backend
  const processedProjectFrames = useMemo(() => {
    return (projectFrames || []).map(frame => ({
      ...frame,
      isActive: frame.id === currentFrame || frame.uuid === currentFrame
    }));
  }, [projectFrames, currentFrame]);

  // Enhanced frame switching handler with smooth transitions
  const handleFrameSwitch = useCallback(async (newFrameId) => {
    if (newFrameId === currentFrame || isFrameSwitching) return;

    console.log('Switching from frame:', currentFrame, 'to frame:', newFrameId);
    
    setIsFrameSwitching(true);
    setSwitchingToFrame(newFrameId);
    
    try {
      // Phase 1: Fade out current content
      setFrameTransitionPhase('fadeOut');
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Phase 2: Show loading state
      setFrameTransitionPhase('loading');
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Save current frame state before switching
      if (canvasComponents.length > 0) {
        setFrameCanvasComponents(prev => ({
          ...prev,
          [currentFrame]: canvasComponents
        }));
      }
      
      // Switch to new frame - In real app, this would navigate via Inertia
      setCurrentFrame(newFrameId);
      
      // Clear current selection when switching frames
      setSelectedComponent(null);
      
      // Load new frame's components (mock data for now)
      const newFrameComponents = frameCanvasComponents[newFrameId] || [];
      if (newFrameComponents.length > 0) {
        generateCode(newFrameComponents);
      }
      
      // Phase 3: Fade in new content
      setFrameTransitionPhase('fadeIn');
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Phase 4: Complete transition
      setFrameTransitionPhase('idle');
      
      console.log('Frame switch completed to:', newFrameId);
      
    } catch (error) {
      console.error('Error during frame switch:', error);
      setFrameTransitionPhase('idle');
    } finally {
      setIsFrameSwitching(false);
      setSwitchingToFrame(null);
    }
  }, [currentFrame, isFrameSwitching, canvasComponents, frameCanvasComponents]);

  // WindowPanel handlers
  const handleOpenWindowPanel = useCallback(() => {
    setWindowPanelState(prev => ({
      ...prev,
      isOpen: true,
      position: { 
        x: Math.max(50, (windowDimensions.width - prev.size.width) / 2), 
        y: Math.max(50, (windowDimensions.height - prev.size.height) / 2)
      }
    }));
  }, [windowDimensions]);

  const handleCloseWindowPanel = useCallback(() => {
    setWindowPanelState(prev => ({
      ...prev,
      isOpen: false
    }));
  }, []);

  // Handle window resize and mobile detection
  useEffect(() => {
    const handleResize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      setWindowDimensions({ width, height });
      setIsMobile(width < 768);
      
      if (width < 768) {
        setCodePanelHeight(Math.min(400, height * 0.6));
      }
    };

    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Initialize component library and load frame-specific data
  useEffect(() => {
    const initializeComponents = async () => {
      try {
        setLoadingMessage('Loading components from database...');
        
        if (typeof componentLibraryService === 'undefined' || !componentLibraryService) {
          console.warn('componentLibraryService not available, using mock data');
          setComponentsLoaded(true);
          setLoadingMessage('');
          return;
        }
        
        await componentLibraryService.loadComponents();
        setComponentsLoaded(true);
        
        // FIXED: Load frame components from backend data first, then try service
        if (frame && frame.canvas_data && frame.canvas_data.components) {
          console.log('Using frame components from backend props');
          const backendComponents = frame.canvas_data.components;
          
          setFrameCanvasComponents(prev => ({
            ...prev,
            [currentFrame]: backendComponents
          }));
          
          if (backendComponents.length > 0) {
            generateCode(backendComponents);
          }
        } else if (projectId && currentFrame && componentLibraryService.loadProjectComponents) {
          // Fallback to service-based loading
          setLoadingMessage('Loading frame components from service...');
          const serviceComponents = await componentLibraryService.loadProjectComponents(projectId, currentFrame);
          if (serviceComponents && serviceComponents.length > 0) {
            setFrameCanvasComponents(prev => ({
              ...prev,
              [currentFrame]: serviceComponents
            }));
            generateCode(serviceComponents);
          }
        }
        
        setLoadingMessage('');
      } catch (error) {
        console.error('Failed to initialize components:', error);
        setComponentsLoaded(true);
        setLoadingMessage('');
      }
    };

    // Only initialize if we have a current frame
    if (currentFrame) {
      initializeComponents();
    }
  }, [currentFrame, projectId]);
  
  if (isForgePanelOpen('layout-presets-panel')) {
  panels.push({
    id: 'layout-presets-panel',
    title: 'Layout Presets',
    content: (
      <LayoutPresets
        onApplyPreset={handlePropertyUpdate}
        selectedComponent={selectedComponent}
        componentLibraryService={componentLibraryService}
      />
    )
  });
}

  // Auto-save frame components when they change
  useEffect(() => {
    const saveComponents = async () => {
        // Only save if we're not in the middle of undo/redo operations
        if (projectId && currentFrame && canvasComponents.length > 0 && componentsLoaded && !isFrameSwitching) {
            try {
                if (componentLibraryService && componentLibraryService.saveProjectComponents) {
                    console.log('Auto-saving', canvasComponents.length, 'components');
                    await componentLibraryService.saveProjectComponents(projectId, currentFrame, canvasComponents);
                }
            } catch (error) {
                console.error('Failed to auto-save components:', error);
            }
        }
    };

    // INCREASED delay for auto-save to reduce conflicts with undo/redo
    const timeoutId = setTimeout(saveComponents, 2000); // 2 seconds instead of 1
    return () => clearTimeout(timeoutId);
}, [canvasComponents, projectId, currentFrame, componentsLoaded, isFrameSwitching]);






// ADD: Asset drop handler
const handleAssetDrop = useCallback((e) => {
  e.preventDefault();
  
  if (!canvasRef.current) return;

  try {
    const dragDataStr = e.dataTransfer.getData('application/json');
    let dragData;
    
    try {
      dragData = JSON.parse(dragDataStr);
    } catch {
      return; // Not an asset drop
    }

    // Check if it's an asset drop
    if (dragData.type !== 'asset') return;

    const { asset, assetType } = dragData;
    
    const canvasRect = canvasRef.current.getBoundingClientRect();
    const x = Math.max(0, e.clientX - canvasRect.left - 50);
    const y = Math.max(0, e.clientY - canvasRect.top - 20);

    // Create appropriate component based on asset type
    let componentType;
    let defaultProps = {};

    switch (assetType) {
      case 'image':
        componentType = 'image';
        defaultProps = {
          src: asset.url,
          alt: asset.name,
          width: asset.dimensions?.width || 'auto',
          height: asset.dimensions?.height || 'auto'
        };
        break;
      case 'video':
        componentType = 'video';
        defaultProps = {
          src: asset.url,
          controls: true,
          width: asset.dimensions?.width || 640,
          height: asset.dimensions?.height || 360
        };
        break;
      case 'audio':
        componentType = 'audio-player';
        defaultProps = {
          src: asset.url,
          title: asset.name,
          duration: asset.duration
        };
        break;
      default:
        // For documents, create a download link component
        componentType = 'link';
        defaultProps = {
          href: asset.url,
          text: asset.name,
          target: '_blank'
        };
        break;
    }

    const newComponent = componentLibraryService?.createLayoutElement 
      ? componentLibraryService.createLayoutElement(componentType, defaultProps)
      : {
          id: `${componentType}_${Date.now()}`,
          type: componentType,
          props: defaultProps,
          position: { x, y },
          name: `${asset.name} (${assetType})`,
          style: {},
          animation: {},
          children: []
        };

    console.log('ForgePage: Dropping asset as component:', newComponent);

    const updatedComponents = [...canvasComponents, newComponent];
    
    setFrameCanvasComponents(prev => ({
      ...prev,
      [currentFrame]: updatedComponents
    }));
    
    pushHistory(currentFrame, updatedComponents, actionTypes.DROP, {
      componentName: newComponent.name,
      componentType: newComponent.type,
      position: { x, y },
      componentId: newComponent.id
    });
    
    setSelectedComponent(newComponent.id);
    generateCode(updatedComponents);
    
  } catch (error) {
    console.error('Error handling asset drop:', error);
  }
}, [canvasComponents, currentFrame, componentLibraryService, pushHistory, actionTypes, generateCode]);







  // Initialize undo/redo when frame and components are ready
  useEffect(() => {
    if (currentFrame && componentsLoaded) {
      console.log('ForgePage: Initializing undo/redo for frame:', currentFrame);
      initUndoRedoFrame(currentFrame);
      
      // Push initial state if we have components
      if (canvasComponents.length > 0) {
        console.log('ForgePage: Pushing initial state with', canvasComponents.length, 'components');
        pushHistory(currentFrame, canvasComponents, actionTypes.INITIAL);
      }
    }
  }, [currentFrame, componentsLoaded, canvasComponents.length, initUndoRedoFrame, pushHistory, actionTypes]);
    
  // Force re-render when ForgeStore state changes
  useEffect(() => {
    console.log('ForgePage: ForgeStore state changed, triggering re-render');
  }, [forgePanelStates, allPanelsHidden, _triggerUpdate, showCodePanel]);

  // Mobile-specific: Force code panel to bottom on mobile
  useEffect(() => {
    if (isMobile && codePanelPosition === 'right') {
      setCodePanelPosition('bottom');
    }
  }, [isMobile, codePanelPosition]);

  // Handle token hover for tooltips
  const handleTokenHover = (e) => {
    if (!showTooltips || isMobile) return
    
    const token = e.target.getAttribute('data-token')
    if (token && tooltipDatabase && tooltipDatabase[token]) {
      const rect = e.target.getBoundingClientRect()
      setHoveredToken({
        token,
        tooltip: tooltipDatabase[token],
        x: rect.left + rect.width / 2,
        y: rect.top - 10
      })
    }
  }

  const handleTokenLeave = () => {
    setHoveredToken(null)
  }

  // Panel handlers
  const handlePanelClose = (panelId) => {
    console.log('ForgePage: Panel close requested for:', panelId);
    toggleForgePanel(panelId)
  }

  const handlePanelStateChange = useCallback((hasRightPanels) => {
    console.log(`Right panels active: ${hasRightPanels}`)
  }, [])

  const handlePanelToggle = useCallback((panelType) => {
    const panelMap = {
      'components': 'components-panel',
      'code': 'code-panel',
      'layers': 'layers-panel'
    }
    
    const actualPanelId = panelMap[panelType]
    console.log('ForgePage: Header panel toggle requested:', panelType, '-> Panel ID:', actualPanelId);
    
    if (actualPanelId) {
      toggleForgePanel(actualPanelId)
    }
  }, [toggleForgePanel])

  const handleComponentTabChange = useCallback((tab) => {
    setActiveComponentTab(tab)
  }, [])

  const handleComponentSearch = useCallback((searchTerm) => {
    setComponentSearchTerm(searchTerm)
  }, [])

  // Component drag handlers
  const handleComponentDragStart = useCallback((e, componentType, variant = null, dragData = null) => {
    console.log('Drag started:', componentType, variant ? `with variant: ${variant.name}` : 'without variant');

    setDragState({
      isDragging: true,
      draggedComponent: {
        type: componentType,
        name: componentType
      },
      variant: variant,
      dragPreview: null
    })

    e.dataTransfer.effectAllowed = 'copy'
    e.dataTransfer.setData('text/plain', JSON.stringify({ componentType, variant }))
  }, [])

  const handleComponentDragEnd = useCallback(() => {
    if (dragState.dragPreview) {
      document.body.removeChild(dragState.dragPreview)
    }
    setDragState({
      isDragging: false,
      draggedComponent: null,
      variant: null,
      dragPreview: null
    })
  }, [dragState.dragPreview])

  // Canvas drop handlers - Updated to work with frame-specific components
  const handleCanvasDragOver = useCallback((e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
    
    // Track drag position for snap lines
    if (canvasRef.current) {
      const canvasRect = canvasRef.current.getBoundingClientRect();
      setDragPosition({
        x: e.clientX - canvasRect.left,
        y: e.clientY - canvasRect.top
      });
    }
  }, []);


    // MODIFY your handleCanvasDrop to use the fixed version with error handling:
  const handleCanvasDrop = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    
    setDragPosition(null);
    
    if (!canvasRef.current) return;
  
    try {
      const componentDataStr = e.dataTransfer.getData('text/plain');
      let dragData;
      
      try {
        dragData = JSON.parse(componentDataStr);
      } catch (err) {
        console.error('Failed to parse drop data:', err);
        return;
      }
  
      const { componentType, variant } = dragData;
      const isLayout = ['section', 'container', 'div', 'flex', 'grid'].includes(componentType);
      
      // Find target container by walking up the DOM
      let targetId = null;
      let element = e.target;
      let searchDepth = 0;
      const MAX_SEARCH_DEPTH = 20;
      
      while (element && element !== canvasRef.current && searchDepth < MAX_SEARCH_DEPTH) {
        const compId = element.getAttribute('data-component-id');
        const isLayoutAttr = element.getAttribute('data-is-layout');
        
        if (compId && isLayoutAttr === 'true') {
          targetId = compId;
          console.log(`Found target container: ${targetId} at depth ${searchDepth}`);
          break;
        }
        
        element = element.parentElement;
        searchDepth++;
      }
  
      let componentDef = componentLibraryService?.getComponentDefinition(componentType);
  
      const newComponent = {
        id: `${componentType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: componentType,
        props: {
          ...(componentDef?.default_props || {}),
          ...(variant?.props || {})
        },
        name: variant ? `${componentType} (${variant.name})` : (componentDef?.name || componentType),
        variant: variant || null,
        style: variant?.style || {},
        animation: {},
        children: [],
        isLayoutContainer: isLayout,
        zIndex: 0,
        sortOrder: 0
      };
  
      let updatedComponents;
      
      if (targetId) {
        // Deep clone to prevent mutation issues
        updatedComponents = JSON.parse(JSON.stringify(canvasComponents));
        
        // Use fixed addChildToContainer with depth tracking
        updatedComponents = addChildToContainer(updatedComponents, targetId, newComponent, 0);
        
        // Verify the update worked
        const verifyComponent = (comps, id) => {
          for (const comp of comps) {
            if (comp.children?.some(child => child.id === id)) return true;
            if (comp.children && verifyComponent(comp.children, id)) return true;
          }
          return false;
        };
        
        const wasAdded = verifyComponent(updatedComponents, newComponent.id);
        
        if (!wasAdded) {
          console.error('Failed to add component to container, adding to root instead');
          updatedComponents = [...canvasComponents, newComponent];
        }
        
      } else if (canvasComponents.length === 0 && !isLayout) {
        // Wrap non-layout in section
        const baseSection = componentLibraryService?.createLayoutElement('section') || {
          id: `section_${Date.now()}`,
          type: 'section',
          props: {},
          children: [],
          isLayoutContainer: true
        };
        baseSection.children = [newComponent];
        updatedComponents = [baseSection];
      } else {
        updatedComponents = [...canvasComponents, newComponent];
      }
      
      // CRITICAL: Validate updated components before setting state
      if (!Array.isArray(updatedComponents)) {
        console.error('Invalid components array, reverting');
        return;
      }
      
      // Force new state reference
      setFrameCanvasComponents(() => ({
        [currentFrame]: updatedComponents
      }));
      
      pushHistory(currentFrame, updatedComponents, actionTypes.DROP, {
        componentName: newComponent.name,
        componentType: newComponent.type,
        targetContainer: targetId || 'root',
        componentId: newComponent.id
      });
      
      setSelectedComponent(newComponent.id);
      handleComponentDragEnd();
      generateCode(updatedComponents);
      
    } catch (error) {
      console.error('❌ CRITICAL Drop error:', error);
      console.error('Error stack:', error.stack);
      
      // Don't let the error crash the page
      handleComponentDragEnd();
      
      // Show user-friendly error
      alert('Failed to drop component. Please try again or check console for details.');
    }
  }, [canvasComponents, currentFrame, componentLibraryService, pushHistory, actionTypes, generateCode]);
  
  // ADD this helper function
const findDropTarget = (components, dropX, dropY, canvasRect) => {
  const sorted = [...components].sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
  
  for (const comp of sorted) {
    if (comp.isLayoutContainer) {
      const element = document.querySelector(`[data-component-id="${comp.id}"]`);
      if (element) {
        const rect = element.getBoundingClientRect();
        const relativeX = dropX + canvasRect.left;
        const relativeY = dropY + canvasRect.top;
        
        if (relativeX >= rect.left && relativeX <= rect.right &&
            relativeY >= rect.top && relativeY <= rect.bottom) {
          
          if (comp.children?.length > 0) {
            const childTarget = findDropTarget(comp.children, dropX, dropY, canvasRect);
            if (childTarget) return childTarget;
          }
          
          return comp;
        }
      }
    }
  }
  
  return null;
};
  
  const getComponentBounds = (comp) => {
      return {
          x: comp.position?.x || 0,
          y: comp.position?.y || 0,
          width: parseInt(comp.style?.width) || 100,
          height: parseInt(comp.style?.minHeight) || 50
      };
  };
  
  const isPointInBounds = (point, bounds) => {
      return point.x >= bounds.x && point.x <= bounds.x + bounds.width &&
             point.y >= bounds.y && point.y <= bounds.y + bounds.height;
  };
  
// REPLACE your existing addChildToContainer with this fixed version:
const addChildToContainer = (components, containerId, newChild, depth = 0) => {
  // Prevent infinite recursion
  const MAX_DEPTH = 10;
  if (depth > MAX_DEPTH) {
    console.error('❌ Maximum nesting depth exceeded:', depth);
    return components;
  }
  
  console.log(`addChildToContainer (depth ${depth}):`, { 
    containerId, 
    newChildId: newChild.id,
    componentsCount: components.length 
  });
  
  let found = false;
  
  const recursiveAdd = (comps, currentDepth) => {
    if (currentDepth > MAX_DEPTH) {
      console.error('Recursion depth exceeded in recursiveAdd');
      return comps;
    }
    
    return comps.map(comp => {
      // Prevent circular references
      if (comp.id === newChild.id) {
        console.warn('⚠️ Attempted to add component as its own child, skipping');
        return comp;
      }
      
      // Direct match
      if (comp.id === containerId) {
        console.log('✅ FOUND direct match:', comp.id);
        found = true;
        
        // Ensure children array exists
        const existingChildren = Array.isArray(comp.children) ? comp.children : [];
        
        // Prevent duplicate children
        if (existingChildren.some(child => child.id === newChild.id)) {
          console.warn('⚠️ Child already exists in container, skipping');
          return comp;
        }
        
        return {
          ...comp,
          children: [...existingChildren, {
            ...newChild,
            sortOrder: existingChildren.length,
            // Add parent reference for easier traversal
            parentId: comp.id
          }]
        };
      }
      
      // Recursive check in children
      if (comp.children && Array.isArray(comp.children) && comp.children.length > 0) {
        const updatedChildren = recursiveAdd(comp.children, currentDepth + 1);
        
        // Only update if children were actually modified
        if (found) {
          console.log(`✅ Found in children of: ${comp.id} (depth ${currentDepth})`);
          return {
            ...comp,
            children: updatedChildren
          };
        }
      }
      
      return comp;
    });
  };
  
  const result = recursiveAdd(components, depth);
  
  if (!found) {
    console.error('❌ Target container not found:', containerId);
    console.error('Available containers:', components.map(c => ({
      id: c.id,
      name: c.name,
      hasChildren: !!c.children?.length,
      childrenIds: c.children?.map(ch => ch.id)
    })));
  }
  
  return result;
};


  
  // ALSO ADD this debug method to check component definitions after loading:
  const debugComponentDefinitions = useCallback(() => {
      if (componentLibraryService) {
          console.log('=== COMPONENT DEFINITIONS DEBUG ===');
          const allDefs = componentLibraryService.getAllComponentDefinitions();
          console.log('Total definitions loaded:', Object.keys(allDefs).length);
          
          Object.entries(allDefs).forEach(([type, def]) => {
              console.log(`${type}:`, {
                  name: def.name,
                  hasDefaults: !!def.default_props,
                  defaults: def.default_props,
                  variants: def.variants?.length || 0
              });
          });
          
          // Check specific components
          ['button', 'card', 'badge'].forEach(type => {
              const def = componentLibraryService.getComponentDefinition(type);
              console.log(`${type} definition:`, def);
          });
      }
  }, [componentLibraryService]);
  
  // ADD this useEffect to debug after components load:
  useEffect(() => {
      if (componentsLoaded && componentLibraryService) {
          // Add a small delay to ensure everything is loaded
          setTimeout(debugComponentDefinitions, 1000);
      }
  }, [componentsLoaded, componentLibraryService, debugComponentDefinitions]);

  // Component selection handler
  const handleComponentClick = useCallback((componentId, e) => {
    e.stopPropagation()
    setSelectedComponent(componentId)
  }, [])

  // ENHANCED: Modified handleComponentDelete to trigger thumbnail updates
const handleComponentDelete = useCallback((componentId) => {
  const componentToDelete = canvasComponents.find(c => c.id === componentId);
  const newComponents = canvasComponents.filter(c => c.id !== componentId)
  
  setFrameCanvasComponents(prev => ({
    ...prev,
    [currentFrame]: newComponents
  }));
  
  pushHistory(currentFrame, newComponents, actionTypes.DELETE, {
    componentName: componentToDelete?.name || componentToDelete?.type || 'component',
    componentId,
    deletedComponent: componentToDelete
  });
  
  if (selectedComponent === componentId) {
    setSelectedComponent(null)
  }
  
  // ENHANCED: Schedule thumbnail update after deletion
  if (currentFrame) {
    const canvasSettings = {
      viewport: getCurrentCanvasDimensions(),
      background_color: frame?.settings?.background_color || '#ffffff',
      responsive_mode: responsiveMode,
      zoom_level: zoomLevel,
      grid_visible: gridVisible
    };
    
    // Schedule thumbnail update (with slight delay)
    setTimeout(() => {
      scheduleThumbnailUpdate(newComponents, canvasSettings);
    }, 300);
  }
  setTimeout(() => {
    if (componentLibraryService?.saveProjectComponents) {
      componentLibraryService.saveProjectComponents(projectId, currentFrame, newComponents);
    }
  }, 200);
  
  generateCode(newComponents)
}, [selectedComponent, canvasComponents, currentFrame, pushHistory, actionTypes, projectId, 
    componentLibraryService, generateCode, scheduleThumbnailUpdate, getCurrentCanvasDimensions, 
    responsiveMode, zoomLevel, gridVisible, frame?.settings]);


const handleIconSelect = useCallback((icon) => {
    console.log('Icon selected in Forge:', icon);
    
    // Create icon component based on selected icon
    const iconComponent = componentLibraryService?.createLayoutElement 
      ? componentLibraryService.createLayoutElement('icon', {
          iconType: icon.type,
          iconName: icon.name,
          size: 24,
          color: 'var(--color-text)',
          svgData: icon.data || null
        })
      : {
          id: `icon_${Date.now()}`,
          type: 'icon',
          props: {
            iconType: icon.type,
            iconName: icon.name,
            size: 24,
            color: 'var(--color-text)',
            svgData: icon.data || null
          },
          position: { x: 100, y: 100 },
          name: `${icon.name} Icon`,
          style: {
            display: 'inline-flex',
            alignItems: 'center',
            justifyContent: 'center',
            width: '24px',
            height: '24px'
          },
          animation: {},
          children: []
        };

    // Add to canvas components
    const updatedComponents = [...canvasComponents, iconComponent];
    
    setFrameCanvasComponents(prev => ({
      ...prev,
      [currentFrame]: updatedComponents
    }));
    
    // Push to undo/redo history
    pushHistory(currentFrame, updatedComponents, actionTypes.DROP, {
      componentName: iconComponent.name,
      componentType: iconComponent.type,
      position: iconComponent.position,
      componentId: iconComponent.id
    });
    
    setSelectedComponent(iconComponent.id);
    generateCode(updatedComponents);
    
    // Auto-save
    setTimeout(() => {
      if (componentLibraryService?.saveProjectComponents) {
        componentLibraryService.saveProjectComponents(projectId, currentFrame, updatedComponents);
      }
    }, 200);
    
  }, [canvasComponents, currentFrame, projectId, pushHistory, actionTypes, componentLibraryService, generateCode]);

  
  // MODIFY: Enhanced property update handler with undo/redo
   // ENHANCED: Modified handlePropertyUpdate to trigger thumbnail updates
const handlePropertyUpdate = useCallback((componentId, propName, value) => {
  const updatedComponents = canvasComponents.map(c => {
    if (c.id === componentId) {
      if (propName === 'position') {
        return { ...c, position: value }
      } else if (propName === 'style') {
        return { ...c, style: { ...c.style, ...value } }
      } else if (propName === 'animation') {
        return { ...c, animation: { ...c.animation, ...value } }
      } else if (propName === 'name') {
        return { ...c, name: value }
      } else if (propName === 'reset') {
        return { 
          ...c, 
          style: {}, 
          animation: {},
          props: {}
        }
      } else {
        return { ...c, props: { ...c.props, [propName]: value } }
      }
    }
    return c
  })
  
  // Update local state immediately
  setFrameCanvasComponents(prev => ({
    ...prev,
    [currentFrame]: updatedComponents
  }));
  
  // Push to history for undo/redo
  const component = canvasComponents.find(c => c.id === componentId);
  const componentName = component?.name || component?.type || 'component';
  
  let actionType = actionTypes.PROP_UPDATE;
  if (propName === 'position') actionType = actionTypes.MOVE;
  else if (propName === 'style') actionType = actionTypes.STYLE_UPDATE;
  
  if (propName === 'position') {
    const oldPos = component?.position || { x: 0, y: 0 };
    const deltaX = Math.abs(value.x - oldPos.x);
    const deltaY = Math.abs(value.y - oldPos.y);
    
    if (deltaX > 5 || deltaY > 5) {
      pushHistory(currentFrame, updatedComponents, actionType, {
        componentName,
        componentId,
        propName,
        value,
        previousValue: oldPos
      });
    }
  } else {
    pushHistory(currentFrame, updatedComponents, actionType, {
      componentName,
      componentId,
      propName,
      value,
      previousValue: propName === 'style' ? component?.style : component?.props?.[propName]
    });
  }
  
  // ENHANCED: Schedule thumbnail update for visual changes
  const shouldUpdateThumbnail = propName !== 'name' && // Skip thumbnail update for name changes
                               (propName === 'style' || propName === 'position' || 
                                propName === 'props' || propName === 'animation');
                                
  if (shouldUpdateThumbnail && updatedComponents.length > 0) {
    const canvasSettings = {
      viewport: getCurrentCanvasDimensions(),
      background_color: frame?.settings?.background_color || '#ffffff',
      responsive_mode: responsiveMode,
      zoom_level: zoomLevel,
      grid_visible: gridVisible
    };
    
    // Schedule debounced thumbnail update
    scheduleThumbnailUpdate(updatedComponents, canvasSettings);
  }
  
  // Auto-save with longer delay to prevent conflicts
  setTimeout(() => {
    if (componentLibraryService?.saveProjectComponents) {
      componentLibraryService.saveProjectComponents(projectId, currentFrame, updatedComponents);
    }
  }, propName === 'position' ? 2000 : 1000);
  
  generateCode(updatedComponents);
}, [canvasComponents, currentFrame, projectId, pushHistory, actionTypes, componentLibraryService, generateCode, 
    scheduleThumbnailUpdate, getCurrentCanvasDimensions, responsiveMode, zoomLevel, gridVisible, frame?.settings]);

  

  
  
  
  
  // ENHANCED: Modified undo/redo handlers to update thumbnails
const handleUndo = useCallback(async () => {
  if (!currentFrame || !canUndo(currentFrame)) {
    console.log('ForgePage: Undo blocked - no frame or cannot undo');
    return;
  }

  console.log('ForgePage: Starting undo operation');
  
  try {
    if (componentLibraryService?.clearSaveQueue) {
      componentLibraryService.clearSaveQueue(currentFrame);
    }
    
    const previousComponents = undo(currentFrame);
    if (previousComponents) {
      console.log('ForgePage: Executing undo - restoring', previousComponents.length, 'components');
      
      setFrameCanvasComponents(prev => ({
        ...prev,
        [currentFrame]: previousComponents
      }));
      
      if (selectedComponent && !previousComponents.find(c => c.id === selectedComponent)) {
        setSelectedComponent(null);
      }
      
      generateCode(previousComponents);
      
      // ENHANCED: Update thumbnail after undo
      const canvasSettings = {
        viewport: getCurrentCanvasDimensions(),
        background_color: frame?.settings?.background_color || '#ffffff',
        responsive_mode: responsiveMode,
        zoom_level: zoomLevel,
        grid_visible: gridVisible
      };
      
      setTimeout(() => {
        scheduleThumbnailUpdate(previousComponents, canvasSettings);
      }, 200);
      
      setTimeout(async () => {
        try {
          if (componentLibraryService?.forceSave) {
            await componentLibraryService.forceSave(projectId, currentFrame, previousComponents);
            console.log('ForgePage: Undo state saved to database');
          }
        } catch (error) {
          console.error('Failed to save undo state:', error);
        }
      }, 100);
      
      console.log('ForgePage: Undo completed successfully');
    }
  } catch (error) {
    console.error('ForgePage: Undo failed:', error);
  }
}, [currentFrame, undo, canUndo, selectedComponent, generateCode, projectId, componentLibraryService, 
    scheduleThumbnailUpdate, getCurrentCanvasDimensions, responsiveMode, zoomLevel, gridVisible, frame?.settings]);



  
  const handleRedo = useCallback(async () => {
  if (!currentFrame || !canRedo(currentFrame)) {
    console.log('ForgePage: Redo blocked - no frame or cannot redo');
    return;
  }

  console.log('ForgePage: Starting redo operation');
  
  try {
    if (componentLibraryService?.clearSaveQueue) {
      componentLibraryService.clearSaveQueue(currentFrame);
    }
    
    const nextComponents = redo(currentFrame);
    if (nextComponents) {
      console.log('ForgePage: Executing redo - restoring', nextComponents.length, 'components');
      
      setFrameCanvasComponents(prev => ({
        ...prev,
        [currentFrame]: nextComponents
      }));
      
      generateCode(nextComponents);
      
      // ENHANCED: Update thumbnail after redo
      const canvasSettings = {
        viewport: getCurrentCanvasDimensions(),
        background_color: frame?.settings?.background_color || '#ffffff',
        responsive_mode: responsiveMode,
        zoom_level: zoomLevel,
        grid_visible: gridVisible
      };
      
      setTimeout(() => {
        scheduleThumbnailUpdate(nextComponents, canvasSettings);
      }, 200);
      
      setTimeout(async () => {
        try {
          if (componentLibraryService?.forceSave) {
            await componentLibraryService.forceSave(projectId, currentFrame, nextComponents);
            console.log('ForgePage: Redo state saved to database');
          }
        } catch (error) {
          console.error('Failed to save redo state:', error);
        }
      }, 100);
      
      console.log('ForgePage: Redo completed successfully');
    }
  } catch (error) {
    console.error('ForgePage: Redo failed:', error);
  }
}, [currentFrame, redo, canRedo, generateCode, projectId, componentLibraryService, 
    scheduleThumbnailUpdate, getCurrentCanvasDimensions, responsiveMode, zoomLevel, gridVisible, frame?.settings]);
    
   // ENHANCED: Add thumbnail status indicator to the UI (optional)
  const renderThumbnailStatus = () => {
    if (!thumbnailGenerating && !thumbnailUrl) return null;
    
    return (
      <div className="fixed bottom-4 left-4 z-50">
        <div className={`flex items-center gap-2 px-3 py-2 rounded-lg backdrop-blur-sm border transition-all duration-200 ${
          thumbnailGenerating 
            ? 'bg-blue-50/90 border-blue-200 text-blue-700' 
            : 'bg-green-50/90 border-green-200 text-green-700'
        }`}>
          <div className={`w-2 h-2 rounded-full ${
            thumbnailGenerating ? 'bg-blue-500 animate-pulse' : 'bg-green-500'
          }`}></div>
          <span className="text-sm font-medium">
            {thumbnailGenerating ? 'Updating preview...' : 'Preview updated'}
          </span>
        </div>
      </div>
    );
  };


  // FIXED: Auto-save with conflict prevention
  useEffect(() => {
    const saveComponents = async () => {
      // CRITICAL: Don't auto-save if undo/redo operations are happening
      if (projectId && currentFrame && canvasComponents.length > 0 && componentsLoaded && !isFrameSwitching) {
        try {
          // Check if we have pending undo/redo operations
          if (componentLibraryService?.hasPendingSave && componentLibraryService.hasPendingSave(currentFrame)) {
            console.log('ForgePage: Skipping auto-save due to pending undo/redo operation');
            return;
          }
          
          if (componentLibraryService?.saveProjectComponents) {
            console.log('ForgePage: Auto-saving', canvasComponents.length, 'components');
            await componentLibraryService.saveProjectComponents(projectId, currentFrame, canvasComponents);
          }
        } catch (error) {
          console.error('Failed to auto-save components:', error);
        }
      }
    };

    // INCREASED delay to prevent conflicts with undo/redo
    const timeoutId = setTimeout(saveComponents, 3000); // 3 seconds
    return () => clearTimeout(timeoutId);
  }, [canvasComponents, projectId, currentFrame, componentsLoaded, isFrameSwitching, componentLibraryService]);

  

  // Handle code editing
  const handleCodeEdit = useCallback((newCode, codeType) => {
    setGeneratedCode(prev => ({
      ...prev,
      [codeType]: newCode
    }))
  }, [])
  
  
  
  
  // ADD cleanup effect when unmounting or changing frames
useEffect(() => {
  return () => {
    // Cleanup function when component unmounts
    console.log('ForgePage: Cleaning up before unmount/navigation');
    
    // Don't clear critical state, but ensure saves are complete
    if (componentLibraryService?.flushPendingSaves) {
      componentLibraryService.flushPendingSaves();
    }
  };
}, []);


// REPLACE WITH THIS (adds Echo cleanup):
useEffect(() => {
  const handleInertiaStart = () => {
    console.log('ForgePage: Navigation starting, preparing to unmount...');
    setIsFrameSwitching(true);
    
    // ✅ ADD THIS: Cleanup Echo channels before navigation
    if (currentFrame) {
      safeLeaveChannel(`presence-frame.${currentFrame}`);
      safeLeaveChannel(`frame-lock.${currentFrame}`);
    }
  };
  
  const handleInertiaFinish = () => {
    console.log('ForgePage: Navigation finished');
    setIsFrameSwitching(false);
  };
  
  router.on('start', handleInertiaStart);
  router.on('finish', handleInertiaFinish);
  
  return () => {
    console.log('ForgePage: Removing Inertia listeners');
    router.off('start', handleInertiaStart);
    router.off('finish', handleInertiaFinish);
    
    // ✅ ADD THIS: Final cleanup
    if (currentFrame) {
      safeLeaveChannel(`presence-frame.${currentFrame}`);
      safeLeaveChannel(`frame-lock.${currentFrame}`);
    }
  };
}, [currentFrame]);  // ✅ ADD currentFrame to dependencies





  
  
  
  
  
  

  const handleCanvasClick = useCallback((e) => {
  // Check if we clicked directly on the canvas (not a component)
  const clickedOnCanvas = e.target === canvasRef.current || 
                         e.target.classList.contains('canvas-root') ||
                         !e.target.closest('[data-component-id]');
  
  if (clickedOnCanvas) {
    console.log('Canvas root clicked, deselecting component');
    setSelectedComponent(null);
    setIsCanvasSelected(false);
  }
}, []);

  // Move code panel to right sidebar
  const moveCodePanelToRightSidebar = useCallback(() => {
    if (!isMobile) {
      setCodePanelPosition('right')
    }
  }, [isMobile])

  // Close code panel handler
  const handleCloseCodePanel = useCallback(() => {
    console.log('ForgePage: Closing code panel via toggle');
    toggleForgePanel('code-panel');
  }, [toggleForgePanel]);

  // Copy code to clipboard
  const copyCodeToClipboard = useCallback(async (code) => {
    try {
      await navigator.clipboard.writeText(code)
      return true;
    } catch (err) {
      console.error('Failed to copy code:', err)
      return false;
    }
  }, [])

  // Download code as file
  const downloadCode = useCallback((code, filename, type) => {
    const element = document.createElement('a')
    const file = new Blob([code], { type: 'text/plain' })
    element.href = URL.createObjectURL(file)
    element.download = `${filename}.${type}`
    document.body.appendChild(element)
    element.click()
    document.body.removeChild(element)
  }, [])

  // Get available tabs based on code style
  const getAvailableTabs = () => {
    switch (codeStyle) {
      case 'react-tailwind':
        return ['react', 'tailwind']
      case 'react-css':
        return ['react', 'css']
      case 'html-css':
        return ['html', 'css']
      case 'html-tailwind':
        return ['html', 'tailwind']
      default:
        return ['react', 'tailwind']
    }
  }

  

  // Get transition classes based on current phase
  const getTransitionClasses = () => {
    switch (frameTransitionPhase) {
      case 'fadeOut':
        return 'opacity-0 scale-95 blur-sm';
      case 'loading':
        return 'opacity-0 scale-95';
      case 'fadeIn':
        return 'opacity-100 scale-100';
      case 'idle':
      default:
        return 'opacity-100 scale-100';
    }
  };

  // WindowPanel dummy content
  const windowPanelContent = (
    <div className="p-6 space-y-4">
      <div className="text-center">
        <h2 className="text-xl font-bold mb-2" style={{ color: 'var(--color-text)' }}>
          Forge Window Panel
        </h2>
        <p className="text-sm" style={{ color: 'var(--color-text-muted)' }}>
          Current Frame: {currentFrame}
        </p>
      </div>
      
      <div className="grid grid-cols-2 gap-4">
        <div className="p-4 rounded-lg" style={{ backgroundColor: 'var(--color-bg-muted)' }}>
          <h3 className="font-semibold mb-2" style={{ color: 'var(--color-text)' }}>
            Canvas Stats
          </h3>
          <div className="text-sm space-y-1" style={{ color: 'var(--color-text-muted)' }}>
            <div>Components: {canvasComponents.length}</div>
            <div>Selected: {selectedComponent ? 'Yes' : 'None'}</div>
            <div>Frame: {currentFrame}</div>
            <div>Switching: {isFrameSwitching ? 'Yes' : 'No'}</div>
          </div>
        </div>
        
        <div className="p-4 rounded-lg" style={{ backgroundColor: 'var(--color-bg-muted)' }}>
          <h3 className="font-semibold mb-2" style={{ color: 'var(--color-text)' }}>
            Frame Info
          </h3>
          <div className="text-sm space-y-1" style={{ color: 'var(--color-text-muted)' }}>
            <div>Total Frames: {projectFrames.length}</div>
            <div>Transition: {frameTransitionPhase}</div>
            <div>Code Panel: {showCodePanel ? 'Open' : 'Closed'}</div>
          </div>
        </div>
      </div>
    </div>
  );

  // Create mock panels for testing
  const createMockPanel = (id, title, content) => ({
    id,
    title,
    content: content || (
      <div className="p-4 space-y-2">
        <h3 className="font-semibold">{title}</h3>
        <p className="text-sm text-gray-600">Mock {title} panel content</p>
        <div className="space-y-1 text-xs text-gray-500">
          <div>This is a placeholder for the {title} panel</div>
          <div>Frame: {currentFrame}</div>
          <div>Components: {canvasComponents.length}</div>
          <div>Switching: {isFrameSwitching ? 'Yes' : 'No'}</div>
        </div>
      </div>
    )
  });

  // Memoize default panels
  const defaultPanels = useMemo(() => [
    createMockPanel('components-panel', 'Components', 
      ComponentsPanel ? (
        <ComponentsPanel
          activeTab={activeComponentTab}
          searchTerm={componentSearchTerm}
          onComponentDragStart={handleComponentDragStart}
          onComponentDragEnd={handleComponentDragEnd}
        />
      ) : null
    ),
    createMockPanel('layers-panel', 'Layers',
      LayersPanel ? (
        <LayersPanel
          canvasComponents={canvasComponents}
          selectedComponent={selectedComponent}
          onComponentSelect={setSelectedComponent}
          onComponentDelete={handleComponentDelete}  // ADD THIS IF MISSING
          searchTerm={componentSearchTerm}  // ADD: Pass search term from Panel
        />
      ) : null
    ),
    createMockPanel('properties-panel', 'Properties',
      PropertiesPanel ? (
        <PropertiesPanel
          canvasComponents={canvasComponents}
          selectedComponent={selectedComponent}
          onPropertyUpdate={handlePropertyUpdate}
          onComponentDelete={handleComponentDelete}
          onGenerateCode={generateCode}
          componentLibraryService={componentLibraryService}
        />
      ) : null
    ),
    createMockPanel('assets-panel', 'Assets',
      AssetsPanel ? (
        <AssetsPanel
          onAssetDrop={handleAssetDrop}
          onAssetSelect={(asset) => console.log('Asset selected:', asset)}
        />
      ) : null
    )
  ], [
    activeComponentTab,
    componentSearchTerm,
    handleComponentDragStart,
    handleComponentDragEnd,
    canvasComponents,
    selectedComponent,
    handlePropertyUpdate,
    handleComponentDelete,
    generateCode,
    handleAssetDrop
  ]);

  // Memoize the sidebar code panel
  const sidebarCodePanel = useMemo(() => ({
    id: 'code-panel',
    title: 'Generated Code',
    content: SidebarCodePanel ? (
      <SidebarCodePanel
        showTooltips={showTooltips && !isMobile}
        setShowTooltips={setShowTooltips}
        codeStyle={codeStyle}
        setCodeStyle={setSyncedCodeStyle}
        activeCodeTab={activeCodeTab}
        setActiveCodeTab={setActiveCodeTab}
        generatedCode={generatedCode}
        getAvailableTabs={getAvailableTabs}
        highlightCode={highlightCode}
        handleTokenHover={handleTokenHover}
        handleTokenLeave={handleTokenLeave}
        handleCodeEdit={handleCodeEdit}
        copyCodeToClipboard={copyCodeToClipboard}
        downloadCode={downloadCode}
        setCodePanelPosition={setCodePanelPosition}
        canvasComponents={canvasComponents}
        generateCode={generateCode}
        isMobile={isMobile}
      />
    ) : (
      <div className="p-4">
        <h3 className="font-semibold mb-2">Generated Code</h3>
        <div className="text-xs text-gray-600">
          Code panel component not available
        </div>
      </div>
    )
  }), [
    showTooltips,
    codeStyle,
    activeCodeTab,
    generatedCode,
    handleCodeEdit,
    copyCodeToClipboard,
    downloadCode,
    canvasComponents,
    generateCode,
    isMobile
  ])

  // Filter visible panels based on ForgeStore state
  const visiblePanels = useMemo(() => {
    console.log('ForgePage: Computing visible panels...');
    
    if (allPanelsHidden) {
      return []
    }
    
    const panels = []
    
    defaultPanels.forEach(panel => {
      const isOpen = isForgePanelOpen(panel.id);
      
      if (panel.id === 'properties-panel' || panel.id === 'assets-panel') {
        panels.push(panel);
      } else if (isOpen) {
        panels.push(panel);
      }
    });
    
    if (codePanelPosition === 'right' && !isMobile && isForgePanelOpen('code-panel')) {
      panels.push(sidebarCodePanel)
    }
    
    return panels
  }, [
    defaultPanels, 
    sidebarCodePanel, 
    codePanelPosition, 
    isMobile, 
    isForgePanelOpen, 
    allPanelsHidden,
    forgePanelStates,
    _triggerUpdate
  ])

  // Check if any panels are visible
  const hasVisiblePanels = useMemo(() => {
    const result = !allPanelsHidden && visiblePanels.length > 0;
    return result;
  }, [allPanelsHidden, visiblePanels])

  // Tab configuration for components panel
  const componentTabConfig = useMemo(() => ({
    defaultTab: 'elements',
    tabs: [
      {
        id: 'elements',
        label: 'Elements',
        icon: Square
      },
      {
        id: 'components',
        label: 'Components',
        icon: Code
      }
    ]
  }), [])

  // Show loading state while components are loading
  if (!componentsLoaded && loadingMessage) {
    return (
      <ErrorBoundary>
      <AuthenticatedLayout
        headerProps={{
          onPanelToggle: handlePanelToggle,
          panelStates: {},
          onModeSwitch: () => {},
          // CRITICAL: Pass the undo/redo handlers to header
          project: project,
          frame: frame,
          canvasComponents: canvasComponents,
          onUndo: handleUndo,          // THIS IS CRITICAL
          onRedo: handleRedo,          // THIS IS CRITICAL
          projectId: projectId,
          currentFrame: currentFrame
        }}
      >
        <Head title="Forge - Visual Builder" />
        
        <div className="h-[calc(100vh-60px)] flex items-center justify-center" style={{ backgroundColor: 'var(--color-bg)' }}>
          <div className="text-center space-y-4">
            <div className="w-16 h-16 border-4 border-purple-200 border-t-purple-600 rounded-full animate-spin mx-auto"></div>
            <div className="text-lg font-medium" style={{ color: 'var(--color-text)' }}>{loadingMessage}</div>
          </div>
        </div>
      </AuthenticatedLayout>
      </ErrorBoundary>
    );
  }

  return (
    <ErrorBoundary>
    <AuthenticatedLayout
      headerProps={{
        onPanelToggle: handlePanelToggle,
        panelStates: {},
        onModeSwitch: () => {}
      }}
    >
      <Head title={`Forge - ${frame?.name || 'Visual Builder'}`} />
      
      {/* Enhanced Tooltip with mobile detection */}
      {CodeTooltip && <CodeTooltip hoveredToken={hoveredToken} showTooltips={showTooltips && !isMobile} />}
      
      {/* Frame Transition Overlay */}
      {isFrameSwitching && (
        <div 
          className="fixed inset-0 z-50 flex items-center justify-center backdrop-blur-sm"
          style={{ backgroundColor: 'rgba(0, 0, 0, 0.4)' }}
        >
          <div 
            className="bg-white rounded-2xl p-8 shadow-2xl border max-w-md w-full mx-4"
            style={{ 
              backgroundColor: 'var(--color-surface)',
              borderColor: 'var(--color-border)'
            }}
          >
            <div className="text-center space-y-4">
              <div className="relative">
                <Loader2 className="w-12 h-12 mx-auto animate-spin" style={{ color: 'var(--color-primary)' }} />
                <div className="absolute inset-0 rounded-full border-2 border-dashed animate-pulse" style={{ borderColor: 'var(--color-primary-soft)' }}></div>
              </div>
              
              <div className="space-y-2">
                <h3 className="text-lg font-semibold" style={{ color: 'var(--color-text)' }}>
                  Switching Frames
                </h3>
                <p className="text-sm" style={{ color: 'var(--color-text-muted)' }}>
                  Loading {switchingToFrame}...
                </p>
              </div>
              
              <div className="bg-gray-100 rounded-full h-1 overflow-hidden" style={{ backgroundColor: 'var(--color-bg-muted)' }}>
                <div 
                  className="h-full rounded-full transition-all duration-300 animate-pulse"
                  style={{ 
                    backgroundColor: 'var(--color-primary)',
                    width: frameTransitionPhase === 'fadeOut' ? '25%' : 
                           frameTransitionPhase === 'loading' ? '75%' : 
                           frameTransitionPhase === 'fadeIn' ? '100%' : '0%'
                  }}
                ></div>
              </div>
            </div>
          </div>
        </div>
      )}
      
      {/* Main content area with transition effects */}
      <div className="h-[calc(100vh-60px)] flex flex-col" style={{ backgroundColor: 'var(--color-bg)' }}>
        <div 
            className={`
                flex-1 flex items-center justify-center transition-all duration-300 ease-in-out
                ${isMobile ? 'p-4' : 'p-8'} ${getCanvasPadding()}
                ${getTransitionClasses()}
                relative
            `}
            style={{
                // Add Huion-style dotted background
                backgroundColor: 'var(--color-bg)',
                backgroundImage: `
                    radial-gradient(circle at 1px 1px, #d1d5db 1px, transparent 0)
                `,
                backgroundSize: '20px 20px',
                backgroundPosition: '0 0'
            }}
        >
            {/* Canvas Component with Enhanced Responsive Sizing */}
            {CanvasComponent ? (
                <div className="relative w-full flex justify-center">
                    {/* Empty Canvas State for Pages */}
                    {frame?.type === 'page' && canvasComponents.length === 0 && (
                        <EmptyCanvasState
                            frameType={frame.type}
                            onAddSection={() => {
                                // Auto-add a section
                                const sectionComponent = componentLibraryService?.createLayoutElement('section');
                                if (sectionComponent) {
                                    const updatedComponents = [sectionComponent];
                                    setFrameCanvasComponents(prev => ({
                                        ...prev,
                                        [currentFrame]: updatedComponents
                                    }));
                                    setSelectedComponent(sectionComponent.id);
                                }
                            }}
                            onDragOver={handleCanvasDragOver}
                            onDrop={handleCanvasDrop}
                            isDragOver={dragState.isDragging}
                        />
                    )}
                    
                    {/* Regular Canvas - only show if we have components or frame is component type */}
                    {(canvasComponents.length > 0 || frame?.type === 'component') && (
                        <CanvasComponent
                          canvasRef={canvasRef}
                          canvasComponents={canvasComponents}
                          selectedComponent={selectedComponent}
                          dragState={dragState}
                          dragPosition={dragPosition}
                          isCanvasSelected={isCanvasSelected}
                          componentLibraryService={componentLibraryService}
                          onCanvasDragOver={handleCanvasDragOver}
                          onCanvasDrop={handleCanvasDrop}
                          onCanvasClick={handleCanvasClick}
                          onComponentClick={handleComponentClick}
                          onPropertyUpdate={handlePropertyUpdate}
                          isMobile={isMobile}
                          currentFrame={currentFrame}
                          isFrameSwitching={isFrameSwitching}
                          frameType={frame?.type || 'page'}
                          responsiveMode={responsiveMode}
                          zoomLevel={zoomLevel}
                          gridVisible={gridVisible}
                          projectId={projectId}  // ADD
                          setFrameCanvasComponents={setFrameCanvasComponents}  // ADD
                          onReorderDragStart={handleReorderDragStart}
                          onReorderDragOver={handleReorderDragOver}
                          onReorderDrop={handleReorderDrop}
                          onReorderDragEnd={handleReorderDragEnd}
                          draggedItem={draggedItem}
                          dragOverItem={dragOverItem}
                      />
                    )}
                </div>
            ) : (
                <div 
                    ref={canvasRef}
                    className="w-full h-full bg-white border-2 border-dashed border-gray-300 rounded-lg 
                               flex items-center justify-center transition-all duration-300"
                    onDragOver={handleCanvasDragOver}
                    onDrop={handleCanvasDrop}
                    onClick={handleCanvasClick}
                >
                    <div className="text-center text-gray-500">
                        <div className="text-lg font-semibold mb-2">Frame: {currentFrame}</div>
                        <div className="text-sm">Drop components here</div>
                    </div>
                </div>
            )}
        </div>
        
        {/* Fixed Code Generation Panel - Bottom (Mobile Optimized) */}
        {BottomCodePanel && (
          <BottomCodePanel
            showCodePanel={showCodePanel && (codePanelPosition === 'bottom' || isMobile)}
            codePanelMinimized={codePanelMinimized}
            codePanelHeight={codePanelHeight}
            codePanelRef={codePanelRef}
            setCodePanelMinimized={setCodePanelMinimized}
            setCodePanelHeight={setCodePanelHeight}
            moveCodePanelToRightSidebar={moveCodePanelToRightSidebar}
            setShowCodePanel={handleCloseCodePanel}
            showTooltips={showTooltips && !isMobile}
            setShowTooltips={setShowTooltips}
            codeStyle={codeStyle}
            setCodeStyle={setSyncedCodeStyle}
            activeCodeTab={activeCodeTab}
            setActiveCodeTab={setActiveCodeTab}
            generatedCode={generatedCode}
            getAvailableTabs={getAvailableTabs}
            highlightCode={highlightCode}
            handleTokenHover={handleTokenHover}
            handleTokenLeave={handleTokenLeave}
            handleCodeEdit={handleCodeEdit}
            copyCodeToClipboard={copyCodeToClipboard}
            downloadCode={downloadCode}
            generateCode={generateCode}
            canvasComponents={canvasComponents}
            setCodePanelPosition={setCodePanelPosition}
            isMobile={isMobile}
            windowDimensions={windowDimensions}
            currentFrame={currentFrame}
            isFrameSwitching={isFrameSwitching}
          />
        )}
      </div>

      {/* Enhanced Panel System with transition support */}
      {Panel && hasVisiblePanels && (
        <Panel
          key={`panel-system-${_triggerUpdate}`}
          isOpen={true}
          initialPanels={visiblePanels}
          allowedDockPositions={isMobile ? ['left'] : ['left', 'right']}
          maxPanelsPerDock={3}
          onPanelClose={handlePanelClose}
          onPanelStateChange={handlePanelStateChange}
          snapToEdge={false}
          mergePanels={true}
          mergePosition="right" // Default merge position for properties + assets
          defaultDockPosition={{
            'properties-panel': 'right',
            'assets-panel': 'right',
            'components-panel': 'left',
            'layers-panel': 'left',
            'code-panel': 'right'
          }}
          showTabs={true}
          showSearch={!isMobile}
          tabConfig={componentTabConfig}
          onTabChange={handleComponentTabChange}
          onSearch={handleComponentSearch}
          searchPlaceholder={`Search ${activeComponentTab}...`}
          isMobile={isMobile}
          defaultWidth={isMobile ? 280 : 320}
          minWidth={isMobile ? 250 : 280}
          maxWidth={isMobile ? 300 : 400}
          isFrameSwitching={isFrameSwitching}
        />
      )}
      
      {/* Enhanced FloatingFrameSwitcher with project frames data */}
      {FloatingFrameSwitcher && (
        <FloatingFrameSwitcher
          currentFrame={currentFrame}
          onFrameSwitch={handleFrameSwitch}
          isMobile={isMobile}
          projectFrames={processedProjectFrames}
          projectId={projectId}
          isFrameSwitching={isFrameSwitching}
          frameTransitionPhase={frameTransitionPhase}
        />
      )}

      {/* WindowPanel Integration */}
      <WindowPanel
        isOpen={windowPanelState.isOpen}
        title={windowPanelState.title}
        content={windowPanelContent}
        onClose={handleCloseWindowPanel}
        onModeChange={() => {}}
        initialMode={windowPanelState.mode}
        initialPosition={windowPanelState.position}
        initialSize={windowPanelState.size}
        minSize={{ width: 400, height: 300 }}
        maxSize={{ width: 1000, height: 700 }}
        isDraggable={true}
        isResizable={true}
        className="forge-window-panel"
        zIndexBase={2000}
        panelCollisionOffset={isMobile ? 280 : 320}
        isMobile={isMobile}
      />

      {/* Mobile-specific: Bottom navigation with enhanced frame switching */}
      {isMobile && (
        <div className="fixed bottom-2 left-1/2 transform -translate-x-1/2 z-40">
          <div className="flex items-center gap-2 bg-black/80 backdrop-blur-md rounded-full px-4 py-2">
            <button
              onClick={() => toggleForgePanel('code-panel')}
              className={`p-2 rounded-full transition-colors ${
                showCodePanel 
                  ? 'bg-white/30 text-white' 
                  : 'text-white/70 hover:bg-white/20'
              }`}
              title="Toggle Code Panel"
              disabled={isFrameSwitching}
            >
              <Code className="w-4 h-4" />
            </button>
            
            {showCodePanel && (
              <>
                <button
                  onClick={() => setCodePanelMinimized(!codePanelMinimized)}
                  className="p-2 rounded-full text-white hover:bg-white/20 transition-colors"
                  title={codePanelMinimized ? 'Expand Code Panel' : 'Minimize Code Panel'}
                  disabled={isFrameSwitching}
                >
                  {codePanelMinimized ? <ChevronUp className="w-4 h-4" /> : <ChevronDown className="w-4 h-4" />}
                </button>
                <button
                  onClick={() => copyCodeToClipboard(generatedCode[activeCodeTab])}
                  className="p-2 rounded-full text-white hover:bg-white/20 transition-colors"
                  title="Copy Code"
                  disabled={isFrameSwitching}
                >
                  <Copy className="w-4 h-4" />
                </button>
                <button
                  onClick={() => generateCode(canvasComponents)}
                  className="p-2 rounded-full text-white hover:bg-white/20 transition-colors"
                  title="Regenerate Code"
                  disabled={isFrameSwitching}
                >
                  <RefreshCw className={`w-4 h-4 ${isFrameSwitching ? 'animate-spin' : ''}`} />
                </button>
              </>
            )}
            
            <button
              onClick={handleOpenWindowPanel}
              className="p-2 rounded-full text-white hover:bg-white/20 transition-colors"
              title="Open Window Panel"
              disabled={isFrameSwitching}
            >
              <PictureInPicture className="w-4 h-4" />
            </button>
          </div>
        </div>
      )}

      {/* Desktop quick actions - MODIFIED */}
      {!isMobile && (
        <div className="fixed bottom-6 right-6 z-30 flex flex-col gap-2">
          {/* ADD Code Panel Mode Switcher */}
          <div className="flex flex-col gap-1 p-2 rounded-lg shadow-lg" style={{ backgroundColor: 'var(--color-surface)', border: '1px solid var(--color-border)' }}>
            <button
              onClick={() => {
                setCodePanelPosition('bottom');
                toggleForgePanel('code-panel');
              }}
              className={`p-2 rounded transition-all ${codePanelPosition === 'bottom' ? 'bg-blue-100' : ''}`}
              title="Bottom Code Panel"
            >
              <ChevronUp className="w-4 h-4" />
            </button>
            <button
              onClick={() => {
                setCodePanelPosition('right');
                toggleForgePanel('code-panel');
              }}
              className={`p-2 rounded transition-all ${codePanelPosition === 'right' ? 'bg-blue-100' : ''}`}
              title="Side Code Panel"
            >
              <ChevronRight className="w-4 h-4" />
            </button>
            <button
              onClick={() => {
                setCodePanelPosition('modal');
                toggleForgePanel('code-modal-panel');
              }}
              className={`p-2 rounded transition-all ${codePanelPosition === 'modal' ? 'bg-blue-100' : ''}`}
              title="Modal Code Panel"
            >
              <PictureInPicture className="w-4 h-4" />
            </button>
          </div>
          
          <button
            onClick={handleOpenWindowPanel}
            className={`p-3 rounded-full shadow-lg transition-all duration-200 hover:scale-110 ${
              isFrameSwitching ? 'opacity-50 cursor-not-allowed' : ''
            }`}
            style={{ 
              backgroundColor: 'var(--color-primary)',
              color: 'white',
              boxShadow: 'var(--shadow-lg)'
            }}
            title="Open Window Panel"
            disabled={isFrameSwitching}
          >
              <Monitor className="w-5 h-5" />
        </button>
      </div>
    )}
      
      {renderThumbnailStatus()}
      
      <IconWindowPanel onIconSelect={handleIconSelect} />
      
      
      {/* Modal Code Panel */}
      {isForgePanelOpen('code-modal-panel') && (
        <ModalCodePanel
          showCodePanel={true}
          setShowCodePanel={() => toggleForgePanel('code-modal-panel')}
          showTooltips={showTooltips}
          setShowTooltips={setShowTooltips}
          codeStyle={codeStyle}
          setCodeStyle={handleCodeStyleChange}
          activeCodeTab={activeCodeTab}
          setActiveCodeTab={setActiveCodeTab}
          generatedCode={generatedCode}
          getAvailableTabs={getAvailableTabs}
          copyCodeToClipboard={copyCodeToClipboard}
          downloadCode={downloadCode}
          generateCode={generateCode}
          canvasComponents={canvasComponents}
          handleCodeEdit={handleCodeEdit}
          isMobile={isMobile}
        />
      )}

      {/* Enhanced mobile performance optimization styles */}
      {isMobile && (
        <style>{`
          * {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
          }
          
          @media (max-width: 768px) {
            .motion-reduce {
              animation-duration: 0.01ms !important;
              animation-iteration-count: 1 !important;
              transition-duration: 0.01ms !important;
            }
            
            .overflow-scroll {
              -webkit-overflow-scrolling: touch;
              scroll-behavior: smooth;
            }
            
            .shadow-lg, .shadow-xl, .shadow-2xl {
              box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24) !important;
            }
          }

          /* Frame transition animations */
          .frame-transition-enter {
            opacity: 0;
            transform: scale(0.95) translateY(10px);
          }
          
          .frame-transition-enter-active {
            opacity: 1;
            transform: scale(1) translateY(0);
            transition: all 300ms ease-out;
          }
          
          .frame-transition-exit {
            opacity: 1;
            transform: scale(1) translateY(0);
          }
          
          .frame-transition-exit-active {
            opacity: 0;
            transform: scale(0.95) translateY(-10px);
            transition: all 200ms ease-in;
          }

          /* Smooth blur animation for frame switching */
          .frame-blur-enter {
            filter: blur(0px);
          }
          
          .frame-blur-active {
            filter: blur(2px);
            transition: filter 200ms ease-in-out;
          }
          
          .frame-blur-exit {
            filter: blur(0px);
            transition: filter 200ms ease-in-out;
          }
        `}</style>
      )}
    </AuthenticatedLayout>
    </ErrorBoundary>
  );
}




// @/Services/ComponentLibraryService.js
import axios from 'axios';
import React from 'react';

class ComponentLibraryService {
  constructor() {
    this.components = new Map();
    this.componentDefinitions = new Map();
  }

  // Load all components from the API
    // REPLACE the loadComponents method in ComponentLibraryService.js (around line 50)
  
  async loadComponents() {
      try {
          console.log('=== LOADING COMPONENTS FROM DATABASE ===');
          
          const response = await axios.get('/api/components');
          if (response.data.success) {
              const componentsByCategory = response.data.data;
              console.log('Raw API response:', componentsByCategory);
              
              let totalLoaded = 0;
              
              // Process both elements and components
              Object.entries(componentsByCategory).forEach(([categoryType, letterGroups]) => {
                  console.log(`Processing category: ${categoryType}`);
                  
                  Object.entries(letterGroups).forEach(([letter, componentList]) => {
                      console.log(`Processing letter group: ${letter}, count: ${componentList.length}`);
                      
                      if (Array.isArray(componentList)) {
                          componentList.forEach(component => {
                              console.log('Processing component:', {
                                  name: component.name,
                                  type: component.type,
                                  hasDefaults: !!component.default_props,
                                  defaults: component.default_props
                              });
                              
                              // Ensure variants are properly parsed
                              let variants = component.variants;
                              if (typeof variants === 'string') {
                                  try {
                                      variants = JSON.parse(variants);
                                  } catch (e) {
                                      console.warn('Failed to parse variants for component:', component.name, e);
                                      variants = [];
                                  }
                              }
                              if (!Array.isArray(variants)) {
                                  variants = [];
                              }
  
                              // CRITICAL: Ensure default_props is properly handled
                              let defaultProps = component.default_props;
                              if (typeof defaultProps === 'string') {
                                  try {
                                      defaultProps = JSON.parse(defaultProps);
                                  } catch (e) {
                                      console.warn('Failed to parse default_props for component:', component.name, e);
                                      defaultProps = {};
                                  }
                              }
                              if (!defaultProps || typeof defaultProps !== 'object') {
                                  defaultProps = {};
                              }
  
                              const processedComponent = {
                                  ...component,
                                  default_props: defaultProps,
                                  variants: variants
                              };
  
                              console.log('Storing component definition:', component.type, {
                                  name: processedComponent.name,
                                  default_props: processedComponent.default_props,
                                  variants_count: processedComponent.variants.length
                              });
  
                              this.componentDefinitions.set(component.type, processedComponent);
                              this.components.set(component.type, this.createComponentRenderer(processedComponent));
                              totalLoaded++;
                          });
                      }
                  });
              });
              
              console.log('=== COMPONENT LOADING COMPLETE ===');
              console.log('Total components loaded:', totalLoaded);
              console.log('Component definitions map size:', this.componentDefinitions.size);
              console.log('Components map size:', this.components.size);
              
              // Debug specific components
              ['button', 'card', 'badge', 'input'].forEach(type => {
                  const def = this.componentDefinitions.get(type);
                  if (def) {
                      console.log(`${type} definition loaded:`, {
                          name: def.name,
                          default_props: def.default_props,
                          variants: def.variants?.length || 0
                      });
                  } else {
                      console.warn(`${type} definition NOT found!`);
                  }
              });
              
              return true;
          }
          
          console.error('API response not successful:', response.data);
          return false;
      } catch (error) {
          console.error('Failed to load components:', error);
          throw error;
      }
  }
  
  renderIcon(props, id) {
    const iconStyle = {
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      width: props.size ? `${props.size}px` : '24px',
      height: props.size ? `${props.size}px` : '24px',
      color: props.color || 'currentColor',
      ...props.style
    };
    
    // Handle different icon types
    if (props.iconType === 'svg' && props.svgData) {
      return React.createElement('div', {
        key: id,
        className: 'icon-svg',
        style: iconStyle,
        dangerouslySetInnerHTML: { __html: props.svgData }
      });
    }
    
    if (props.iconType === 'lottie') {
      // Lottie animation placeholder
      return React.createElement('div', {
        key: id,
        className: 'icon-lottie',
        style: iconStyle
      }, '🎬');
    }
    
    // For Lucide/Heroicons, show icon name placeholder
    return React.createElement('div', {
      key: id,
      className: 'icon-element',
      style: iconStyle,
      title: `${props.iconName} (${props.iconType})`
    }, React.createElement('span', {
      style: { fontSize: '12px' }
    }, '🎨'));
  }
  
  
    // In ComponentLibraryService.js - ADD this method
    createLayoutElement(type, props = {}) {
      const componentDef = this.componentDefinitions.get(type);
      if (!componentDef) {
          console.warn('No definition for layout type:', type);
          return null;
      }
  
      const layoutElement = {
          id: `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          type: type,
          props: {
              ...componentDef.default_props,
              ...props
          },
          name: props.name || componentDef.name,
          style: {
              display: type === 'flex' ? 'flex' : type === 'grid' ? 'grid' : 'block',
              width: '100%',
              minHeight: type === 'section' ? '200px' : '100px',
              padding: props.style?.padding || '24px',
              backgroundColor: 'transparent',
              ...props.style
          },
          children: [],
          isLayoutContainer: true,
          acceptsChildren: true,
          zIndex: props.zIndex || 0
      };
  
      return layoutElement;
  }


    // ALSO fix the createComponentRenderer method to ensure proper defaults:
  createComponentRenderer(componentDef) {
      console.log('Creating renderer for:', componentDef.type, {
          hasDefaults: !!componentDef.default_props,
          defaults: componentDef.default_props
      });
      
      return {
          id: componentDef.type,
          name: componentDef.name,
          description: componentDef.description,
          icon: componentDef.icon,
          defaultProps: componentDef.default_props || {}, // Ensure this exists
          propDefinitions: componentDef.prop_definitions,
          variants: componentDef.variants || [],
          
          // Dynamic render function
          render: (props, id) => {
              return this.renderComponent(componentDef, props, id);
          },
  
          // Generate code function
          generateCode: (props, allComponents, style) => {
              return this.generateComponentCode(componentDef, props, allComponents, style);
          }
      };
  }

  // Dynamic component renderer with enhanced variant support
   renderComponent(componentDef, props, id) {
        // Get the component definition if not passed
       if (!componentDef && this.componentDefinitions.has(props.type || props.component_type)) {
            componentDef = this.componentDefinitions.get(props.type || props.component_type);
        }
        
        if (!componentDef) {
            console.warn('No component definition found for:', props.type || props.component_type);
            return this.renderGeneric(props, id, { name: props.type || 'Unknown', type: props.type || 'unknown' });
        }
        
        // CRITICAL FIX: Properly merge default props with instance props
        const mergedProps = { 
            ...componentDef.default_props,
            ...props.props,
            ...props
        };
        
        // Check if this is a layout container
      const isLayoutContainer = props.isLayoutContainer || 
                               ['section', 'container', 'div', 'flex', 'grid'].includes(componentDef.type);
      
      if (isLayoutContainer) {
          return this.renderLayoutContainer(componentDef, mergedProps, id, props.children || []);
      }
        
        console.log('Rendering component:', componentDef.type, 'with merged props:', mergedProps);
        
        // Check if there's a variant being used
        if (props.variant && componentDef.variants) {
            const variantData = componentDef.variants.find(v => v.name === props.variant.name);
            if (variantData) {
                // If variant has preview code, use it
                if (variantData.preview_code) {
                    return React.createElement('div', {
                        key: id,
                        dangerouslySetInnerHTML: {
                            __html: variantData.preview_code.replace(/className=/g, 'class=')
                        }
                    });
                }
                
                  // Merge variant props with merged props
                if (variantData.props) {
                    Object.assign(mergedProps, variantData.props);
                }
            }
        }
        
        
        
        
        switch (componentDef.type) {
            case 'button':
                return this.renderButton(mergedProps, id);
            case 'input':
                return this.renderInput(mergedProps, id);
            // case 'card':
//                 return this.renderCard(mergedProps, id, layoutStyles);
//             case 'avatar':
//                 return this.renderAvatar(mergedProps, id, layoutStyles);
//             case 'badge':
//                 return this.renderBadge(mergedProps, id, layoutStyles);
//             case 'searchbar':
//                 return this.renderSearchbar(mergedProps, id, layoutStyles);
            default:
                return this.renderGeneric(mergedProps, id, componentDef, layoutStyles);
        }
    }
    
    
    // ADD this new method
     renderLayoutContainer(componentDef, props, id, children) {
        const containerStyle = {
            display: props.style?.display || this.getDefaultDisplay(componentDef.type),
            flexDirection: props.style?.flexDirection,
            justifyContent: props.style?.justifyContent,
            alignItems: props.style?.alignItems,
            gap: props.style?.gap,
            gridTemplateColumns: props.style?.gridTemplateColumns,
            width: props.style?.width || '100%',
            minHeight: props.style?.minHeight || this.getDefaultMinHeight(componentDef.type),
            padding: props.style?.padding || this.getDefaultPadding(componentDef.type),
            backgroundColor: 'transparent',
            border: props.style?.border,
            borderRadius: props.style?.borderRadius,
            ...props.style
        };
        
        return React.createElement('div', {
            key: id,
            'data-layout-type': componentDef.type,
            'data-component-id': id,
            className: `layout-container ${componentDef.type}-container`,
            style: containerStyle
        }, children && children.length > 0 ? children.map(child => 
            this.renderComponent(this.componentDefinitions.get(child.type), child, child.id)
        ) : null);
    }
    
    
    // Helper methods
    getDefaultDisplay(type) {
        const displayMap = {
            'flex': 'flex',
            'grid': 'grid',
            'section': 'block',
            'container': 'block',
            'div': 'block'
        };
        return displayMap[type] || 'block';
    }
    
    getDefaultMinHeight(type) {
        const minHeightMap = {
            'section': '200px',
            'container': '100px',
            'div': '50px',
            'flex': '100px',
            'grid': '100px'
        };
        return minHeightMap[type] || 'auto';
    }
    
    getDefaultPadding(type) {
        const paddingMap = {
            'section': '48px 24px',
            'container': '24px',
            'div': '16px',
            'flex': '16px',
            'grid': '16px'
        };
        return paddingMap[type] || '0';
    }

      
    // Button renderer with enhanced variant support
    renderButton(props, id, layoutStyles = {}) {
        const className = this.getButtonClasses(props);
        
        const buttonStyle = {
            maxWidth: '100%',
            wordBreak: 'break-word',
            whiteSpace: 'nowrap',
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            width: props.width || 'fit-content',
            minWidth: props.minWidth || '60px',
            ...layoutStyles, // Apply layout styles
            ...props.style   // Allow override
        };
        
        return React.createElement('button', {
            key: id,
            className,
            onClick: () => console.log(`Button ${id} clicked`),
            disabled: props.disabled || false,
            style: buttonStyle
        }, props.text || props.children || 'Button');
    }

  // Avatar renderer
  renderAvatar(props, id) {
    const className = this.getAvatarClasses(props);
    
    if (props.src) {
      return React.createElement('div', {
        key: id,
        className
      }, React.createElement('img', {
        src: props.src,
        alt: props.alt || 'Avatar',
        className: 'w-full h-full object-cover'
      }));
    }
    
    const initials = props.initials || props.name?.charAt(0) || 'A';
    return React.createElement('div', {
      key: id,
      className,
      style: props.style
    }, React.createElement('span', {
      className: 'font-medium'
    }, initials));
  }



  // Input renderer
  renderInput(props, id, layoutStyles = {}) {
      const className = this.getInputClasses(props);
      
      const inputStyle = {
          width: props.width || '100%',
          maxWidth: props.maxWidth || '250px',
          ...layoutStyles,
          ...props.style
      };
      
      return React.createElement('input', {
          key: id,
          type: props.type || 'text',
          placeholder: props.placeholder || '',
          className,
          disabled: props.disabled || false,
          required: props.required || false,
          style: inputStyle
      });
  }

  // Searchbar renderer
  renderSearchbar(props, id) {
    const className = this.getSearchbarClasses(props);
    
    return React.createElement('div', {
      key: id,
      className,
      style: props.style
    }, [
      React.createElement('input', {
        key: `${id}-input`,
        type: 'text',
        placeholder: props.placeholder || 'Search...',
        className: 'flex-1 bg-transparent outline-none'
      }),
      React.createElement('svg', {
        key: `${id}-icon`,
        className: 'w-5 h-5 text-gray-400',
        fill: 'none',
        stroke: 'currentColor',
        viewBox: '0 0 24 24'
      }, React.createElement('path', {
        strokeLinecap: 'round',
        strokeLinejoin: 'round',
        strokeWidth: 2,
        d: 'M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'
      }))
    ]);
  }

  // Card renderer
  renderCard(props, id, layoutStyles = {}) {
      const cardClassName = this.getCardClasses(props);
      
      const cardStyle = {
          ...layoutStyles,
          ...props.style
      };
      
      return React.createElement('div', {
          key: id,
          className: cardClassName,
          style: cardStyle
      }, [
          props.title && React.createElement('h3', {
              key: `${id}-title`,
              className: 'font-semibold text-lg mb-2 text-gray-900'
          }, props.title),
          React.createElement('div', {
              key: `${id}-content`,
              className: 'text-gray-600'
          }, props.content || props.children || 'Card content')
      ]);
  }

  // Enhanced generic renderer with size constraints
renderGeneric(props, id, componentDef) {
  const containerStyle = {
    maxWidth: '200px',
    overflow: 'hidden',
    ...props.style
  };
  
  return React.createElement('div', {
    key: id,
    className: 'p-4 border-2 border-dashed border-gray-300 rounded-lg bg-gray-50 text-center shrink-0',
    title: `${componentDef.name} component`,
    style: containerStyle
  }, [
    React.createElement('div', {
      key: `${id}-name`,
      className: 'font-semibold text-gray-700 truncate'
    }, componentDef.name),
    React.createElement('div', {
      key: `${id}-type`,
      className: 'text-xs text-gray-500 mt-1 truncate'
    }, `(${componentDef.type})`)
  ]);
}

// Enhanced button classes with proper width constraints
getButtonClasses(props) {
  const baseClasses = "inline-flex items-center justify-center font-medium rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 shrink-0";
  
  const variantClasses = {
    primary: "bg-gradient-to-r from-purple-600 to-blue-600 text-white hover:from-purple-700 hover:to-blue-700 focus:ring-purple-500 shadow-lg hover:shadow-xl",
    secondary: "bg-white text-gray-900 border-2 border-gray-200 hover:bg-gray-50 focus:ring-gray-500 shadow-sm hover:shadow-md",
    success: "bg-gradient-to-r from-emerald-500 to-teal-600 text-white hover:from-emerald-600 hover:to-teal-700 focus:ring-emerald-500 shadow-lg hover:shadow-xl",
    warning: "bg-gradient-to-r from-amber-500 to-orange-500 text-white hover:from-amber-600 hover:to-orange-600 focus:ring-amber-500 shadow-lg hover:shadow-xl",
    danger: "bg-gradient-to-r from-red-500 to-pink-600 text-white hover:from-red-600 hover:to-pink-700 focus:ring-red-500 shadow-lg hover:shadow-xl",
    ghost: "bg-transparent text-purple-600 hover:bg-purple-50 focus:ring-purple-500 border border-transparent hover:border-purple-200",
    gradient: "bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg hover:shadow-xl transform hover:-translate-y-0.5 transition-all",
    neon: "bg-black border-2 border-cyan-400 text-cyan-400 shadow-lg shadow-cyan-400/50 hover:shadow-cyan-400/75",
    glass: "bg-white/20 backdrop-blur-md border border-white/30 text-white shadow-xl",
    outline: "border-2 border-purple-600 text-purple-600 hover:bg-purple-600 hover:text-white",
    minimal: "text-gray-700 hover:text-gray-900 hover:bg-gray-100",
    default: "bg-gray-100 text-gray-900 hover:bg-gray-200"
  };
  
  // Enhanced size classes with max-width constraints
  const sizeClasses = {
    xs: "px-2 py-1 text-xs min-w-[40px] max-w-[120px]",
    sm: "px-3 py-1.5 text-sm min-w-[50px] max-w-[150px]", 
    md: "px-6 py-2.5 text-base min-w-[60px] max-w-[200px]",
    lg: "px-8 py-4 text-lg min-w-[80px] max-w-[250px]",
    xl: "px-10 py-5 text-xl min-w-[100px] max-w-[300px]"
  };
  
  const variant = props.variant || 'primary';
  const size = props.size || 'md';
  
  return `${baseClasses} ${variantClasses[variant] || variantClasses.primary} ${sizeClasses[size] || sizeClasses.md} ${props.className || ''}`;
}

// Enhanced button renderer with overflow prevention
renderButton(props, id) {
  const className = this.getButtonClasses(props);
  
  // Enhanced style with overflow prevention
  const buttonStyle = {
    maxWidth: '100%',
    wordBreak: 'break-word',
    whiteSpace: 'nowrap',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    width: props.width || 'fit-content',
    minWidth: props.minWidth || '60px',
    ...props.style
  };
  
  return React.createElement('button', {
    key: id,
    className,
    onClick: () => console.log(`Button ${id} clicked`),
    disabled: props.disabled || false,
    style: buttonStyle
  }, props.text || 'Button');
}

// Enhanced avatar classes with size constraints
getAvatarClasses(props) {
  const baseClasses = "rounded-full flex items-center justify-center overflow-hidden shrink-0";
  
  const variantClasses = {
    default: "bg-gray-300 text-gray-600",
    primary: "bg-purple-100 text-purple-600",
    success: "bg-green-100 text-green-600",
    warning: "bg-yellow-100 text-yellow-600",
    danger: "bg-red-100 text-red-600",
    gradient: "bg-gradient-to-r from-purple-400 to-pink-400 text-white",
    bordered: "bg-white border-2 border-gray-300 text-gray-600"
  };
  
  // Fixed size classes with exact dimensions
  const sizeClasses = {
    xs: "w-6 h-6 text-xs min-w-[24px] max-w-[24px]",
    sm: "w-8 h-8 text-sm min-w-[32px] max-w-[32px]",
    md: "w-12 h-12 text-base min-w-[48px] max-w-[48px]",
    lg: "w-16 h-16 text-lg min-w-[64px] max-w-[64px]",
    xl: "w-20 h-20 text-xl min-w-[80px] max-w-[80px]"
  };
  
  const variant = props.variant || 'default';
  const size = props.size || 'md';
  
  return `${baseClasses} ${variantClasses[variant] || variantClasses.default} ${sizeClasses[size] || sizeClasses.md} ${props.className || ''}`;
}

// Enhanced badge classes with size constraints
getBadgeClasses(props) {
  const baseClasses = "inline-block rounded-full font-medium shrink-0";
  
  const variantClasses = {
    default: "bg-gray-100 text-gray-800",
    primary: "bg-blue-100 text-blue-800",
    success: "bg-green-100 text-green-800",
    warning: "bg-yellow-100 text-yellow-800",
    danger: "bg-red-100 text-red-800",
    info: "bg-cyan-100 text-cyan-800",
    gradient: "bg-gradient-to-r from-purple-400 to-pink-400 text-white",
    outline: "border-2 border-gray-300 bg-transparent text-gray-700"
  };
  
  // Size classes with max-width to prevent overflow
  const sizeClasses = {
    xs: "px-1.5 py-0.5 text-xs max-w-[80px]",
    sm: "px-2 py-0.5 text-xs max-w-[100px]",
    md: "px-2.5 py-1 text-sm max-w-[120px]",
    lg: "px-3 py-1.5 text-base max-w-[150px]"
  };
  
  const variant = props.variant || 'default';
  const size = props.size || 'md';
  
  return `${baseClasses} ${variantClasses[variant] || variantClasses.default} ${sizeClasses[size] || sizeClasses.md} ${props.className || ''}`;
}

// Enhanced input classes with width constraints
getInputClasses(props) {
  const baseClasses = "block rounded-lg border transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-offset-1 shrink-0";
  
  const variantClasses = {
    default: "border-gray-300 focus:border-blue-500 focus:ring-blue-500",
    error: "border-red-300 focus:border-red-500 focus:ring-red-500",
    success: "border-green-300 focus:border-green-500 focus:ring-green-500",
    minimal: "border-0 border-b-2 border-gray-300 rounded-none focus:border-blue-500",
    filled: "bg-gray-100 border-gray-100 focus:bg-white focus:border-blue-500"
  };
  
  // Size classes with width constraints
  const sizeClasses = {
    sm: "px-3 py-1.5 text-sm w-full max-w-[200px]",
    md: "px-4 py-2.5 text-base w-full max-w-[250px]",
    lg: "px-5 py-3 text-lg w-full max-w-[300px]"
  };
  
  const variant = props.variant || 'default';
  const size = props.size || 'md';
  
  return `${baseClasses} ${variantClasses[variant] || variantClasses.default} ${sizeClasses[size] || sizeClasses.md} ${props.className || ''}`;
}

// Enhanced searchbar classes with width constraints
getSearchbarClasses(props) {
  const baseClasses = "flex items-center rounded-lg border transition-colors duration-200 shrink-0";
  
  const variantClasses = {
    default: "bg-white border-gray-300 focus-within:border-blue-500",
    filled: "bg-gray-100 border-gray-100 focus-within:bg-white focus-within:border-blue-500",
    minimal: "bg-transparent border-0 border-b-2 border-gray-300 rounded-none focus-within:border-blue-500",
    elevated: "bg-white shadow-md border-0 focus-within:shadow-lg"
  };
  
  // Size classes with width constraints
  const sizeClasses = {
    sm: "px-3 py-1.5 w-full max-w-[200px]",
    md: "px-4 py-2.5 w-full max-w-[250px]",
    lg: "px-5 py-3 w-full max-w-[300px]"
  };
  
  const variant = props.variant || 'default';
  const size = props.size || 'md';
  
  return `${baseClasses} ${variantClasses[variant] || variantClasses.default} ${sizeClasses[size] || sizeClasses.md} ${props.className || ''}`;
}

// Enhanced card classes with width constraints
getCardClasses(props) {
  const baseClasses = "rounded-lg shrink-0";
  
  const variantClasses = {
    default: "bg-white border border-gray-200",
    outlined: "bg-transparent border-2 border-gray-300",
    elevated: "bg-white shadow-lg border-0",
    flat: "bg-gray-50 border-0",
    gradient: "bg-gradient-to-br from-purple-50 to-blue-50 border border-purple-200",
    glass: "bg-white/20 backdrop-blur-md border border-white/30"
  };
  
  const paddingClasses = {
    none: "p-0",
    sm: "p-3",
    md: "p-4",
    lg: "p-6",
    xl: "p-8"
  };
  
  // Size constraints for cards
  const sizeClasses = {
    sm: "max-w-[200px]",
    md: "max-w-[300px]", 
    lg: "max-w-[400px]",
    xl: "max-w-[500px]",
    full: "w-full max-w-full"
  };
  
  const variant = props.variant || 'default';
  const padding = props.padding || 'md';
  const size = props.size || 'md';
  const shadow = (props.shadow && variant !== 'elevated') ? 'shadow-sm' : '';
  
  return `${baseClasses} ${variantClasses[variant] || variantClasses.default} ${paddingClasses[padding] || paddingClasses.md} ${sizeClasses[size] || sizeClasses.md} ${shadow} ${props.className || ''}`;
}



  // Enhanced code generation with variant support
  async generateComponentCode(componentDef, props, allComponents, style) {
    try {
      // Try server-side generation first
      const response = await axios.post('/api/components/generate-code', {
        components: allComponents,
        style: style
      });
      
      if (response.data.success) {
        return response.data.data;
      }
    } catch (error) {
      console.warn('Server-side code generation failed, using client-side fallback:', error);
    }
    
    // Fallback to client-side generation
    return this.clientSideCodeGeneration(allComponents, style);
  }

  // Client-side code generation with enhanced variant support
  // Around line 500 in ComponentLibraryService.js
    clientSideCodeGeneration(allComponents, style) {
        console.log('Generating code for', allComponents.length, 'components with style:', style);
        
        const codeMap = {
          'react-tailwind': () => this.generateReactTailwindCode(allComponents),
          'react-css': () => this.generateReactCSSCode(allComponents),
          'html-css': () => this.generateHTMLCSSCode(allComponents),
          'html-tailwind': () => this.generateHTMLTailwindCode(allComponents)
        };
        
        return codeMap[style]?.() || { react: '', html: '', css: '', tailwind: '' };
    }
    
    // ADD THIS NEW METHOD right after clientSideCodeGeneration
    getTabsForStyle(style) {
        const tabMap = {
          'react-tailwind': ['react'], // Single combined tab
          'react-css': ['react', 'css'], // Two separate tabs
          'html-css': ['html', 'css'], // Two separate tabs
          'html-tailwind': ['html'] // Single combined tab
        };
        
        return tabMap[style] || ['react'];
    }

  generateReactTailwindCode(allComponents) {
  if (!allComponents || allComponents.length === 0) {
    return {
      react: `import React from 'react';

const GeneratedComponent = () => {
  return (
    <div className="w-full min-h-screen p-8">
      {/* No components yet */}
    </div>
  );
};

export default GeneratedComponent;`,
      tailwind: '// No components to generate classes for'
    };
  }

  // REMOVE the position absolute wrapper - just render components directly
  const reactComponents = allComponents.map(comp => {
    const classes = this.getComponentClasses(comp);
    return this.generateComponentJSX(comp, classes); // NO WRAPPER
  }).join('\n');

  return {
    react: `import React from 'react';

const GeneratedComponent = () => {
  return (
    <div className="w-full min-h-screen">
${reactComponents}
    </div>
  );
};

export default GeneratedComponent;`,
    tailwind: allComponents.map(comp => `// ${comp.name} (${comp.type})\n${this.getComponentClasses(comp)}`).join('\n\n')
  };
}

  generateReactCSSCode(allComponents) {
  // REMOVE position absolute wrapper
  const reactComponents = allComponents.map(comp => {
    return this.generateComponentJSX(comp, `btn btn-${comp.props.variant || 'primary'} btn-${comp.props.size || 'md'}`);
  }).join('\n');

  return {
    react: `import React from 'react';
import './GeneratedComponent.css';

const GeneratedComponent = () => {
  return (
    <div className="canvas-container">
${reactComponents}
    </div>
  );
};

export default GeneratedComponent;`,
    css: this.generateCSSStyles(allComponents)
  };
}

  generateHTMLCSSCode(allComponents) {
  // REMOVE position absolute wrapper
  const htmlComponents = allComponents.map(comp => {
    return this.generateComponentHTML(comp, `btn btn-${comp.props.variant || 'primary'} btn-${comp.props.size || 'md'}`);
  }).join('\n');

  return {
    html: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Component</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="canvas-container">
${htmlComponents}
    </div>
</body>
</html>`,
    css: this.generateCSSStyles(allComponents)
  };
}

  generateHTMLTailwindCode(allComponents) {
  // REMOVE position absolute wrapper
  const htmlComponents = allComponents.map(comp => {
    const classes = this.getComponentClasses(comp);
    return this.generateComponentHTML(comp, classes);
  }).join('\n');

  return {
    html: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Component</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div class="w-full min-h-screen">
${htmlComponents}
    </div>
</body>
</html>`,
    tailwind: allComponents.map(comp => `/* ${comp.name} (${comp.type}) */\n${this.getComponentClasses(comp)}`).join('\n\n')
  };
}

  // Enhanced JSX generation with variant support
  generateComponentJSX(comp, classes) {
    const componentDef = this.componentDefinitions.get(comp.type);
    if (!componentDef) return `<div className="${classes}">${comp.name || comp.type}</div>`;

    // Handle variant-specific rendering
    if (comp.variant && comp.variant.preview_code) {
      return comp.variant.preview_code;
    }

    switch (comp.type) {
      case 'button':
        return `<button className="${classes}" ${comp.props.disabled ? 'disabled' : ''}>${comp.props.text || comp.variant?.text || 'Button'}</button>`;
      case 'avatar':
        if (comp.props.src) {
          return `<div className="${classes}"><img src="${comp.props.src}" alt="${comp.props.alt || 'Avatar'}" className="w-full h-full object-cover" /></div>`;
        }
        const initials = comp.props.initials || comp.props.name?.charAt(0) || 'A';
        return `<div className="${classes}"><span className="font-medium">${initials}</span></div>`;
      case 'badge':
        return `<span className="${classes}">${comp.props.text || comp.variant?.text || 'Badge'}</span>`;
      case 'input':
        return `<input type="${comp.props.type || 'text'}" placeholder="${comp.props.placeholder || ''}" className="${classes}" ${comp.props.required ? 'required' : ''} ${comp.props.disabled ? 'disabled' : ''} />`;
      case 'searchbar':
        return `<div className="${classes}">
          <input type="text" placeholder="${comp.props.placeholder || 'Search...'}" className="flex-1 bg-transparent outline-none" />
          <svg className="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        </div>`;
      case 'card':
        return `<div className="${classes}">
            ${comp.props.title ? `<h3 className="font-semibold text-lg mb-2 text-gray-900">${comp.props.title}</h3>` : ''}
            <div className="text-gray-600">${comp.props.content || 'Card content'}</div>
          </div>`;
      default:
        return `<div className="${classes}">${comp.name || componentDef.name}</div>`;
    }
  }

  // Enhanced HTML generation with variant support
  generateComponentHTML(comp, classes) {
    const componentDef = this.componentDefinitions.get(comp.type);
    if (!componentDef) return `<div class="${classes}">${comp.name || comp.type}</div>`;

    // Handle variant-specific rendering
    if (comp.variant && comp.variant.preview_code) {
      return comp.variant.preview_code.replace(/className=/g, 'class=');
    }

    switch (comp.type) {
      case 'button':
        return `<button class="${classes}" ${comp.props.disabled ? 'disabled' : ''}>${comp.props.text || comp.variant?.text || 'Button'}</button>`;
      case 'avatar':
        if (comp.props.src) {
          return `<div class="${classes}"><img src="${comp.props.src}" alt="${comp.props.alt || 'Avatar'}" class="w-full h-full object-cover" /></div>`;
        }
        const initials = comp.props.initials || comp.props.name?.charAt(0) || 'A';
        return `<div class="${classes}"><span class="font-medium">${initials}</span></div>`;
      case 'badge':
        return `<span class="${classes}">${comp.props.text || comp.variant?.text || 'Badge'}</span>`;
      case 'input':
        return `<input type="${comp.props.type || 'text'}" placeholder="${comp.props.placeholder || ''}" class="${classes}" ${comp.props.required ? 'required' : ''} ${comp.props.disabled ? 'disabled' : ''} />`;
      case 'searchbar':
        return `<div class="${classes}">
          <input type="text" placeholder="${comp.props.placeholder || 'Search...'}" class="flex-1 bg-transparent outline-none" />
          <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        </div>`;
      case 'card':
        return `<div class="${classes}">
        ${comp.props.title ? `<h3 class="font-semibold text-lg mb-2 text-gray-900">${comp.props.title}</h3>` : ''}
        <div class="text-gray-600">${comp.props.content || 'Card content'}</div>
      </div>`;
      default:
        return `<div class="${classes}">${comp.name || componentDef.name}</div>`;
    }
  }

  generateCSSStyles(allComponents) {
    return `.canvas-container {
  position: relative;
  width: 100%;
  height: 100%;
  min-height: 400px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 12px;
}

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-weight: 500;
  border-radius: 8px;
  transition: all 0.2s ease;
  border: none;
  cursor: pointer;
  font-family: 'Inter', sans-serif;
}

.btn:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
}

.btn-primary {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  box-shadow: 0 4px 14px rgba(102, 126, 234, 0.4);
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
}

.btn-secondary {
  background: white;
  color: #374151;
  border: 2px solid #e5e7eb;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn-secondary:hover {
  background: #f9fafb;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.btn-success {
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  color: white;
  box-shadow: 0 4px 14px rgba(16, 185, 129, 0.4);
}

.btn-warning {
  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
  color: white;
  box-shadow: 0 4px 14px rgba(245, 158, 11, 0.4);
}

.btn-danger {
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  color: white;
  box-shadow: 0 4px 14px rgba(239, 68, 68, 0.4);
}

.btn-ghost {
  background: transparent;
  color: #7c3aed;
  border: 1px solid transparent;
}

.btn-ghost:hover {
  background: #f3f4f6;
  border-color: #e5e7eb;
}

.btn-gradient {
  background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
  color: white;
  box-shadow: 0 4px 14px rgba(168, 85, 247, 0.4);
  transform: translateY(0);
  transition: all 0.2s ease;
}

.btn-gradient:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(168, 85, 247, 0.6);
}

.btn-neon {
  background: black;
  border: 2px solid #06b6d4;
  color: #06b6d4;
  box-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
}

.btn-neon:hover {
  box-shadow: 0 0 20px rgba(6, 182, 212, 0.8);
}

.btn-glass {
  background: rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(16px);
  border: 1px solid rgba(255, 255, 255, 0.3);
  color: white;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.btn-outline {
  background: transparent;
  border: 2px solid #7c3aed;
  color: #7c3aed;
}

.btn-outline:hover {
  background: #7c3aed;
  color: white;
}

.btn-minimal {
  background: transparent;
  border: none;
  color: #374151;
}

.btn-minimal:hover {
  background: #f3f4f6;
  color: #111827;
}

.btn-xs {
  padding: 4px 8px;
  font-size: 0.75rem;
}

.btn-sm {
  padding: 6px 12px;
  font-size: 0.875rem;
}

.btn-md {
  padding: 10px 24px;
  font-size: 1rem;
}

.btn-lg {
  padding: 16px 32px;
  font-size: 1.125rem;
}

.btn-xl {
  padding: 20px 40px;
  font-size: 1.25rem;
}

/* Avatar styles */
.avatar {
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  background-color: #d1d5db;
  color: #6b7280;
}

/* Badge styles */
.badge {
  display: inline-block;
  border-radius: 9999px;
  font-weight: 500;
}

.badge-default {
  background-color: #f3f4f6;
  color: #374151;
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
}

.badge-primary {
  background-color: #dbeafe;
  color: #1d4ed8;
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
}

.badge-success {
  background-color: #dcfce7;
  color: #166534;
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
}

.badge-warning {
  background-color: #fef3c7;
  color: #92400e;
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
}

.badge-danger {
  background-color: #fee2e2;
  color: #991b1b;
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
}

/* Input styles */
.input {
  display: block;
  width: 100%;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 1rem;
  transition: all 0.2s ease;
}

.input:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

/* Card styles */
.card {
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 1rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* Searchbar styles */
.searchbar {
  display: flex;
  align-items: center;
  background: white;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  padding: 0.5rem 1rem;
  transition: all 0.2s ease;
}

.searchbar:focus-within {
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.component-default {
  padding: 1rem;
  border: 2px dashed #d1d5db;
  border-radius: 8px;
  background-color: #f9fafb;
  text-align: center;
}`;
  }

  getComponentClasses(comp) {
    switch (comp.type) {
      case 'button':
        return this.getButtonClasses(comp.props);
      case 'avatar':
        return this.getAvatarClasses(comp.props);
      case 'badge':
        return this.getBadgeClasses(comp.props);
      case 'input':
        return this.getInputClasses(comp.props);
      case 'searchbar':
        return this.getSearchbarClasses(comp.props);
      case 'card':
        return this.getCardClasses(comp.props);
      default:
        return 'p-4 border-2 border-dashed border-gray-300 rounded-lg bg-gray-50';
    }
  }

  // Get component by type
  getComponent(type) {
    return this.components.get(type);
  }

  // Get component definition
  getComponentDefinition(type) {
    return this.componentDefinitions.get(type);
  }

  // Get all components
  getAllComponents() {
    return Object.fromEntries(this.components);
  }

  // Get all component definitions
  getAllComponentDefinitions() {
    return Object.fromEntries(this.componentDefinitions);
  }


async saveProjectComponents(projectId, frameId, components) {
    try {
        console.log('=== SAVING TO DATABASE ===');
        console.log('Components to save:', components.length);
        
        // CRITICAL: Create a Set to track component IDs and prevent duplicates
        const seenIds = new Set();
        
        // CRITICAL: Flatten component tree for backend
        const flattenedComponents = this.flattenComponentTree(components, seenIds);
        
        console.log('Flattened components:', flattenedComponents.length);
        console.log('Duplicate IDs removed:', components.length - flattenedComponents.length);
        
        const response = await axios.post('/api/project-components/bulk-update', {
            project_id: projectId,
            frame_id: frameId,
            components: flattenedComponents.map((comp, index) => ({
                // CRITICAL: Map frontend fields to backend fields
                id: comp.id,                              
                type: comp.type,                          
                props: comp.props || {},
                name: comp.name || comp.type,
                zIndex: comp.zIndex || 0,
                sortOrder: index,                         
                variant: comp.variant || null,
                style: comp.style || {},
                animation: comp.animation || {},
                isLayoutContainer: comp.isLayoutContainer || false,
                children: comp.children || [],            
                parentId: comp.parentId || null,          
            })),
            create_revision: false
        });
        
        if (response.data.success) {
            console.log('✅ Successfully saved to database');
            return true;
        }
        
        console.error('❌ Save failed:', response.data.message);
        return false;
    } catch (error) {
        console.error('❌ Failed to save components:', error.response?.data || error.message);
        throw error;
    }
}

// ENHANCED: Flatten nested component tree with duplicate detection
flattenComponentTree(components, seenIds = new Set(), parentId = null) {
    const flattened = [];
    
    components.forEach(comp => {
        // CRITICAL: Skip duplicates
        if (seenIds.has(comp.id)) {
            console.warn('⚠️ Duplicate component ID detected, skipping:', comp.id);
            return;
        }
        
        // Mark as seen
        seenIds.add(comp.id);
        
        // Add current component with parent reference
        const flatComp = {
            ...comp,
            parentId: parentId
        };
        
        flattened.push(flatComp);
        
        // Recursively flatten children
        if (comp.children && comp.children.length > 0) {
            const childrenFlat = this.flattenComponentTree(comp.children, seenIds, comp.id);
            flattened.push(...childrenFlat);
        }
    });
    
    return flattened;
}

// ENHANCED: Rebuild tree from flattened database records with duplicate prevention
rebuildComponentTree(flatComponents) {
    const componentMap = new Map();
    const rootComponents = [];
    const seenIds = new Set();
    
    // First pass: Create map of all components, skip duplicates
    flatComponents.forEach(comp => {
        if (seenIds.has(comp.id)) {
            console.warn('⚠️ Duplicate component in database response, skipping:', comp.id);
            return;
        }
        
        seenIds.add(comp.id);
        componentMap.set(comp.id, {
            ...comp,
            children: []
        });
    });
    
    // Second pass: Build parent-child relationships
    flatComponents.forEach(comp => {
        if (!seenIds.has(comp.id)) return; // Skip duplicates
        
        const component = componentMap.get(comp.id);
        
        if (comp.parentId) {
            const parent = componentMap.get(comp.parentId);
            if (parent) {
                parent.children.push(component);
            } else {
                // Parent not found, treat as root
                rootComponents.push(component);
            }
        } else {
            rootComponents.push(component);
        }
    });
    
    return rootComponents;
}

    // ENHANCED: Load with tree reconstruction
  async loadProjectComponents(projectId, frameId) {
      try {
          console.log('Loading project components for:', { projectId, frameId });
          
          const response = await axios.get('/api/project-components', {
              params: { project_id: projectId, frame_id: frameId }
          });
          
          if (response.data.success) {
              const flatComponents = response.data.data;
              console.log('Loaded', flatComponents.length, 'components from backend');
              
              // CRITICAL: Rebuild tree structure
              const treeComponents = this.rebuildComponentTree(flatComponents);
              
              console.log('Rebuilt tree with', treeComponents.length, 'root components');
              
              return treeComponents;
          }
          
          return [];
      } catch (error) {
          console.error('Failed to load project components:', error);
          return [];
      }
  }
}

// Create singleton instance
export const componentLibraryService = new ComponentLibraryService();
export default componentLibraryService;



// stores/useEditorStore.js - Enhanced with proper responsive mode persistence
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

const useEditorStore = create(
  persist(
    (set, get) => ({
      // Void and Forge page states
      responsiveMode: 'desktop',
      zoomLevel: 80,
      interactionMode: 'cursor',
      editMode: 'edit',
      inspectMode: false,
      gridVisible: false,
      
      // Navigation state for Forge/Source
      activeNav: 'Forge',
      
      // Panel states - now with default states for the 4 panels
      panelStates: {
        'frames-panel': false,        // Button 2 - Frames Panel
        'files-panel': false,         // Button 3 - Project Files Panel  
        'code-panel': false,          // Button 4 - Code Handler Panel
        'team-panel': false           // Button 5 - Team Collaboration Panel
      },
      
      // Canvas dimensions based on responsive mode (for persistence)
      canvasDimensions: {
        desktop: { width: '100%', maxWidth: '100%', height: '100%', minHeight: '400px' },
        tablet: { width: '768px', maxWidth: '768px', height: '1024px', minHeight: '1024px' },
        mobile: { width: '375px', maxWidth: '375px', height: '667px', minHeight: '667px' }
      },
      
      // Actions
      setResponsiveMode: (mode) => {
        console.log(`EditorStore: Setting responsive mode to ${mode}`);
        set({ responsiveMode: mode });
        
        // Trigger canvas update event for components that need to respond
        if (typeof window !== 'undefined') {
          window.dispatchEvent(new CustomEvent('responsive-mode-changed', { 
            detail: { mode, timestamp: Date.now() } 
          }));
        }
      },
      
      // Get current canvas dimensions based on responsive mode
      getCurrentCanvasDimensions: () => {
        const { responsiveMode, canvasDimensions } = get();
        return canvasDimensions[responsiveMode] || canvasDimensions.desktop;
      },
      
      // Get responsive scale factor for components
      getResponsiveScaleFactor: () => {
        const { responsiveMode } = get();
        switch (responsiveMode) {
          case 'mobile':
            return 0.8;
          case 'tablet':
            return 0.9;
          case 'desktop':
          default:
            return 1;
        }
      },
      
      // Get responsive device info
      getResponsiveDeviceInfo: () => {
        const { responsiveMode } = get();
        
        const deviceInfo = {
          mobile: { 
            width: 375, 
            height: 667, 
            maxWidth: 375, 
            deviceName: 'iPhone SE',
            icon: 'Smartphone',
            breakpoint: 'max-width: 767px'
          },
          tablet: { 
            width: 768, 
            height: 1024, 
            maxWidth: 768, 
            deviceName: 'iPad',
            icon: 'Tablet',
            breakpoint: 'min-width: 768px and max-width: 1023px'
          },
          desktop: { 
            width: 1200, 
            height: 800, 
            maxWidth: '100%', 
            deviceName: 'Desktop',
            icon: 'Monitor',
            breakpoint: 'min-width: 1024px'
          }
        };
        
        return deviceInfo[responsiveMode] || deviceInfo.desktop;
      },
      
      // Toggle between responsive modes (cycle through them)
      cycleResponsiveMode: () => {
        const { responsiveMode } = get();
        const modes = ['desktop', 'tablet', 'mobile'];
        const currentIndex = modes.indexOf(responsiveMode);
        const nextIndex = (currentIndex + 1) % modes.length;
        const nextMode = modes[nextIndex];
        
        console.log(`EditorStore: Cycling responsive mode from ${responsiveMode} to ${nextMode}`);
        get().setResponsiveMode(nextMode);
      },
      
      // Check if current mode is mobile
      isMobileMode: () => {
        return get().responsiveMode === 'mobile';
      },
      
      // Check if current mode is tablet
      isTabletMode: () => {
        return get().responsiveMode === 'tablet';
      },
      
      // Check if current mode is desktop
      isDesktopMode: () => {
        return get().responsiveMode === 'desktop';
      },
      
      // Get responsive CSS classes for canvas
      getResponsiveCanvasClasses: () => {
        const { responsiveMode } = get();
        
        const baseClasses = 'transition-all duration-500 ease-in-out mx-auto';
        
        switch (responsiveMode) {
          case 'mobile':
            return `${baseClasses} border-purple-400 shadow-lg rounded-lg`;
          case 'tablet':
            return `${baseClasses} border-blue-400 shadow-lg rounded-lg`;
          case 'desktop':
          default:
            return `${baseClasses} border-gray-300 border-dashed`;
        }
      },
      
      // Get responsive grid background
      getResponsiveGridBackground: () => {
        const { responsiveMode, gridVisible } = get();
        
        if (!gridVisible || responsiveMode === 'desktop') {
          return {};
        }
        
        const gridSize = responsiveMode === 'mobile' ? '20px' : '24px';
        const gridColor = responsiveMode === 'mobile' ? '#A052FF' : '#3B82F6';
        
        return {
          backgroundImage: `
            linear-gradient(to right, ${gridColor} 1px, transparent 1px),
            linear-gradient(to bottom, ${gridColor} 1px, transparent 1px)
          `,
          backgroundSize: `${gridSize} ${gridSize}`,
          opacity: 0.1
        };
      },
      
      setZoomLevel: (level) => {
        const clampedLevel = Math.max(25, Math.min(200, level));
        console.log(`EditorStore: Setting zoom level to ${clampedLevel}%`);
        set({ zoomLevel: clampedLevel });
      },
      
      setInteractionMode: (mode) => set({ interactionMode: mode }),
      
      setEditMode: (mode) => set({ editMode: mode }),
      
      setInspectMode: (mode) => set({ inspectMode: mode }),
      
      setActiveNav: (nav) => set({ activeNav: nav }),
      
      // Enhanced panel actions
      togglePanel: (panelId) => {
        set((state) => {
          const newPanelStates = {
            ...state.panelStates,
            [panelId]: !state.panelStates[panelId]
          }
          
          // Log for debugging
          console.log(`EditorStore: Toggling panel ${panelId}: ${state.panelStates[panelId]} -> ${newPanelStates[panelId]}`)
          
          return { panelStates: newPanelStates }
        })
      },
      
      setPanelState: (panelId, isOpen) => set((state) => ({
        panelStates: {
          ...state.panelStates,
          [panelId]: isOpen
        }
      })),
      
      // Close all panels
      closeAllPanels: () => set((state) => ({
        panelStates: Object.keys(state.panelStates).reduce((acc, key) => {
          acc[key] = false
          return acc
        }, {})
      })),
      
      setGridVisible: (visible) => {
        console.log(`EditorStore: Setting grid visibility to ${visible}`);
        set({ gridVisible: visible });
      },
      
      toggleGridVisible: () => set((state) => { 
        const newVisible = !state.gridVisible;
        console.log(`EditorStore: Toggling grid visibility to ${newVisible}`);
        return { gridVisible: newVisible };
      }),
      
      // Open specific panel and close others (exclusive mode)
      openPanelExclusive: (panelId) => set((state) => ({
        panelStates: Object.keys(state.panelStates).reduce((acc, key) => {
          acc[key] = key === panelId
          return acc
        }, {})
      })),
      
      // Get panel state helper
      isPanelOpen: (panelId) => {
        return get().panelStates[panelId] || false
      },
      
      // Get count of open panels
      getOpenPanelsCount: () => {
        const { panelStates } = get()
        return Object.values(panelStates).filter(Boolean).length
      },
      
      // Initialize navigation state from URL
      initializeNavFromUrl: (url) => {
        if (url.includes('/modeForge')) {
          set({ activeNav: 'Forge' })
        } else if (url.includes('/modeSource')) {
          set({ activeNav: 'Source' })
        }
      },
      
      // Initialize responsive mode from localStorage or default
      initializeResponsiveMode: () => {
        if (typeof window !== 'undefined') {
          const stored = localStorage.getItem('decode-editor-storage');
          if (stored) {
            try {
              const parsed = JSON.parse(stored);
              const mode = parsed?.state?.responsiveMode || 'desktop';
              console.log(`EditorStore: Initializing responsive mode from storage: ${mode}`);
              set({ responsiveMode: mode });
            } catch (error) {
              console.warn('EditorStore: Failed to parse stored responsive mode, using desktop');
              set({ responsiveMode: 'desktop' });
            }
          }
        }
      },
      
      // Reset states for page transitions
      resetForPage: (pageName) => {
        if (pageName === 'forge') {
          set({ 
            activeNav: 'Forge',
            inspectMode: false,
            editMode: 'edit'
          })
        } else if (pageName === 'source') {
          set({ 
            activeNav: 'Source',
            inspectMode: false,
            editMode: 'edit'
          })
        } else if (pageName === 'void') {
          set({
            responsiveMode: get().responsiveMode, // Keep current responsive mode
            zoomLevel: 80,
            interactionMode: 'cursor'
          })
        }
      },
      
      // Debug helper
      debugCurrentState: () => {
        const state = get();
        console.log('=== EDITOR STORE DEBUG ===');
        console.log('Responsive Mode:', state.responsiveMode);
        console.log('Canvas Dimensions:', state.getCurrentCanvasDimensions());
        console.log('Device Info:', state.getResponsiveDeviceInfo());
        console.log('Scale Factor:', state.getResponsiveScaleFactor());
        console.log('Zoom Level:', state.zoomLevel);
        console.log('Grid Visible:', state.gridVisible);
        console.log('Panel States:', state.panelStates);
        console.log('==========================');
      }
    }),
    {
      name: 'decode-editor-storage', // localStorage key
      version: 2, // Increment for schema changes
      partialize: (state) => ({
        // Persist all UI preferences including responsive mode
        panelStates: state.panelStates,
        responsiveMode: state.responsiveMode,
        zoomLevel: state.zoomLevel,
        gridVisible: state.gridVisible,
        interactionMode: state.interactionMode,
        canvasDimensions: state.canvasDimensions
      }),
      // Handle version migration
      migrate: (persistedState, version) => {
        if (version === 0 || version === 1) {
          // Ensure we have all required fields
          return {
            ...persistedState,
            responsiveMode: persistedState.responsiveMode || 'desktop',
            canvasDimensions: persistedState.canvasDimensions || {
              desktop: { width: '100%', maxWidth: '100%', height: '100%', minHeight: '400px' },
              tablet: { width: '768px', maxWidth: '768px', height: '1024px', minHeight: '1024px' },
              mobile: { width: '375px', maxWidth: '375px', height: '667px', minHeight: '667px' }
            }
          };
        }
        return persistedState;
      }
    }
  )
)

export { useEditorStore }





// @/Components/Forge/ComponentsPanel.jsx - FIXED Tab Switching Reset
import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Layers, 
  Code, 
  Search, 
  ChevronDown,
  ChevronRight,
  Square,
  User,
  Tag,
  Layout,
  Menu,
  Zap,
  Move,
  Palette,
  Sparkles,
  MousePointer,
  Image,
  Play
} from 'lucide-react';
import axios from 'axios';

const iconMap = {
  Square, Code, Layers, User, Layout, Search, Menu, Zap, Tag, Palette, Sparkles, MousePointer, Image, Play
};

// Category definitions with icons and descriptions
const CATEGORIES = {
  layout: {
    icon: Layout,
    label: 'Layout',
    description: 'Structural elements and containers',
    color: '#10b981'
  },
  interactive: {
    icon: MousePointer,
    label: 'Interactive',
    description: 'Buttons, forms, and interactive elements',
    color: '#3b82f6'
  },
  media: {
    icon: Image,
    label: 'Media',
    description: 'Images, videos, and media elements',
    color: '#f59e0b'
  },
  display: {
    icon: Sparkles,
    label: 'Display',
    description: 'Text, badges, and visual elements',
    color: '#8b5cf6'
  },
  navigation: {
    icon: Menu,
    label: 'Navigation',
    description: 'Navigation bars and menus',
    color: '#ef4444'
  },
  form: {
    icon: Tag,
    label: 'Forms',
    description: 'Form inputs and controls',
    color: '#06b6d4'
  }
};

const ComponentsPanel = ({ 
  onComponentDragStart, 
  onComponentDragEnd,
  activeTab = 'elements',
  searchTerm = '',
  onTabChange,
  onSearch
}) => {
  const [components, setComponents] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [selectedLetter, setSelectedLetter] = useState(null);
  const [selectedComponent, setSelectedComponent] = useState(null);
  const [showVariants, setShowVariants] = useState(false);
  const [expandedCategories, setExpandedCategories] = useState({
    layout: true, // Layout expanded by default
    interactive: false,
    media: false,
    display: false,
    navigation: false,
    form: false
  });

  // Internal state for tabs and search when not controlled externally
  const [internalActiveTab, setInternalActiveTab] = useState(activeTab);
  const [internalSearchTerm, setInternalSearchTerm] = useState(searchTerm);

  // Use internal state if external handlers are not provided
  const currentActiveTab = onTabChange ? activeTab : internalActiveTab;
  const currentSearchTerm = onSearch ? searchTerm : internalSearchTerm;

  // Tab configuration
  const tabConfig = {
    tabs: [
      { id: 'elements', label: 'Elements', icon: Square },
      { id: 'components', label: 'Components', icon: Code }
    ]
  };
  
  // CLEANER FIX: Use a ref to track tab changes and avoid the useEffect loop
  const previousTabRef = useRef(currentActiveTab);
  
  useEffect(() => {
    // Only reset if the tab actually changed
    if (previousTabRef.current !== currentActiveTab) {
      console.log('ComponentsPanel: Tab changed from', previousTabRef.current, 'to:', currentActiveTab);
      setShowVariants(false);
      setSelectedComponent(null);
      previousTabRef.current = currentActiveTab;
    }
  }, [currentActiveTab]); // Remove showVariants from dependencies

  useEffect(() => {
    fetchComponents();
  }, []);

  const fetchComponents = async () => {
    setLoading(true);
    try {
      const response = await axios.get('/api/components');
      
      if (response.data.success) {
        const allComponents = response.data.data;
        
        // Group by component_type (elements vs components)
        const grouped = { elements: {}, components: {} };
        
        Object.entries(allComponents).forEach(([componentType, letterGroups]) => {
          if (letterGroups && typeof letterGroups === 'object') {
            Object.entries(letterGroups).forEach(([letter, componentList]) => {
              if (Array.isArray(componentList)) {
                if (!grouped[componentType][letter]) {
                  grouped[componentType][letter] = [];
                }
                
                const processedComponents = componentList.map(component => {
                  let variants = component.variants;
                  if (typeof variants === 'string') {
                    try {
                      variants = JSON.parse(variants);
                    } catch (e) {
                      variants = [];
                    }
                  }
                  if (!Array.isArray(variants)) {
                    variants = [];
                  }
                  
                  return {
                    ...component,
                    variants: variants,
                    alphabet_group: component.alphabet_group || component.name?.charAt(0)?.toUpperCase() || 'A'
                  };
                });
                
                grouped[componentType][letter] = [...grouped[componentType][letter], ...processedComponents];
              }
            });
          }
        });
        
        setComponents(grouped);
      } else {
        setError('Failed to load components: ' + (response.data.message || 'Unknown error'));
      }
    } catch (err) {
      setError('Failed to load components: ' + err.message);
    } finally {
      setLoading(false);
    }
  };

  // Group components by category
  const componentsByCategory = useMemo(() => {
    const currentTypeComponents = components[currentActiveTab] || {};
    const categorized = {};
    
    // Initialize all categories
    Object.keys(CATEGORIES).forEach(category => {
      categorized[category] = [];
    });
    
    // Sort components into categories
    Object.entries(currentTypeComponents).forEach(([letter, letterComponents]) => {
      if (!Array.isArray(letterComponents)) return;
      
      letterComponents.forEach(component => {
        // Skip if search term doesn't match
        if (currentSearchTerm && 
            !component.name?.toLowerCase().includes(currentSearchTerm.toLowerCase()) &&
            !component.description?.toLowerCase().includes(currentSearchTerm.toLowerCase()) &&
            !component.category?.toLowerCase().includes(currentSearchTerm.toLowerCase())) {
          return;
        }

        const category = component.category || 'layout';
        if (categorized[category]) {
          categorized[category].push(component);
        } else {
          categorized['layout'].push(component); // Fallback to layout
        }
      });
    });
    
    return categorized;
  }, [components, currentActiveTab, currentSearchTerm]);

  // FIXED: Enhanced tab change handler with proper reset
  const handleTabChange = (tab) => {
    console.log('ComponentsPanel: handleTabChange called with tab:', tab);
    
    if (onTabChange) {
      onTabChange(tab);
    } else {
      setInternalActiveTab(tab);
    }
    
    // CRITICAL: Always reset variants view when changing tabs
    setShowVariants(false);
    setSelectedComponent(null);
    setSelectedLetter(null);
    
    // Clear search as well
    if (onSearch) {
      onSearch('');
    } else {
      setInternalSearchTerm('');
    }
    
    console.log('ComponentsPanel: Tab change completed, variants view reset');
  };

  const handleSearch = (value) => {
    if (onSearch) {
      onSearch(value);
    } else {
      setInternalSearchTerm(value);
    }
  };

  const toggleCategory = (categoryKey) => {
    setExpandedCategories(prev => ({
      ...prev,
      [categoryKey]: !prev[categoryKey]
    }));
  };

  const handleComponentClick = (component) => {
    if (component.variants && Array.isArray(component.variants) && component.variants.length > 0) {
      console.log('ComponentsPanel: Showing variants for component:', component.name);
      setSelectedComponent(component);
      setShowVariants(true);
    } else {
      console.log('ComponentsPanel: No variants, starting drag for component:', component.name);
      handleMainComponentDragStart(component);
    }
  };

  const handleMainComponentDragStart = (component) => {
    const dragData = {
      componentType: component.type,
      variant: null,
      component: {
        name: component.name,
        type: component.type,
        description: component.description,
        default_props: component.default_props,
        prop_definitions: component.prop_definitions
      }
    };

    const syntheticEvent = {
      dataTransfer: {
        effectAllowed: 'copy',
        setData: (type, data) => JSON.stringify(dragData)
      }
    };

    if (onComponentDragStart) {
      onComponentDragStart(syntheticEvent, component.type, null);
    }
  };

  const handleVariantDragStart = (e, component, variant) => {
    e.stopPropagation();
    
    const dragData = {
      componentType: component.type,
      variant: variant,
      component: {
        id: component.id,
        name: component.name,
        type: component.type,
        description: component.description,
        default_props: component.default_props,
        prop_definitions: component.prop_definitions,
        category: component.category,
        icon: component.icon
      }
    };
    
    e.dataTransfer.effectAllowed = 'copy';
    e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
    e.dataTransfer.setData('application/json', JSON.stringify(dragData));
    
    // Create drag preview
    const dragPreview = document.createElement('div');
    dragPreview.style.cssText = `
      position: absolute;
      top: -1000px;
      left: -1000px;
      z-index: 9999;
      padding: 8px;
      background: var(--color-surface);
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      pointer-events: none;
      box-shadow: var(--shadow-lg);
      border: 2px solid var(--color-border);
      max-width: 120px;
      max-height: 60px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    `;
    
    if (variant.preview_code) {
      dragPreview.innerHTML = `
        <div style="transform: scale(0.8); transform-origin: center;">
          ${variant.preview_code.replace(/className=/g, 'class=')}
        </div>
      `;
    } else {
      dragPreview.innerHTML = `
        <div style="padding: 4px 8px; background: var(--color-bg-muted); border-radius: 4px; font-size: 10px; color: var(--color-text);">
          ${variant.name || component.name}
        </div>
      `;
    }
    
    document.body.appendChild(dragPreview);
    e.dataTransfer.setDragImage(dragPreview, 60, 30);
    
    setTimeout(() => {
      if (document.body.contains(dragPreview)) {
        document.body.removeChild(dragPreview);
      }
    }, 100);
    
    if (onComponentDragStart) {
      onComponentDragStart(e, component.type, variant, dragData);
    }
  };

  const handleVariantDragEnd = (e) => {
    if (onComponentDragEnd) {
      onComponentDragEnd(e);
    }
  };

  // FIXED: Back button with better reset
  const handleBackClick = () => {
    console.log('ComponentsPanel: Back button clicked, returning to category view');
    setShowVariants(false);
    setSelectedComponent(null);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-8 min-h-[400px]" style={{ backgroundColor: 'var(--color-bg)' }}>
        <div className="flex flex-col items-center space-y-4">
          <svg className="w-8 h-8 animate-spin" viewBox="0 0 24 24" fill="none" style={{ color: 'var(--color-primary)' }}>
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v8H4z" />
          </svg>
          <span style={{ color: 'var(--color-text-muted)' }}>Loading components...</span>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-4 text-center" style={{ backgroundColor: 'var(--color-bg)' }}>
        <div className="mb-2" style={{ color: 'var(--color-text)' }}>{error}</div>
        <button 
          onClick={fetchComponents}
          className="px-4 py-2 rounded transition-colors hover:opacity-90"
          style={{ 
            backgroundColor: 'var(--color-primary)', 
            color: 'white'
          }}
        >
          Retry
        </button>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col" style={{ backgroundColor: 'var(--color-bg)' }}>
      {/* FIXED: Enhanced Tabs Section with better visual feedback */}
      <div className="p-4 border-b" style={{ borderColor: 'var(--color-border)' }}>
        <div className="relative rounded-xl p-1" style={{ backgroundColor: 'var(--color-bg-muted)' }}>
          <motion.div
            className="absolute top-1 bottom-1 rounded-lg shadow-md"
            style={{ backgroundColor: 'var(--color-surface)' }}
            initial={false}
            animate={{
              left: currentActiveTab === tabConfig.tabs[0].id ? '4px' : 'calc(50% + 2px)',
              width: 'calc(50% - 6px)'
            }}
            transition={{ type: "spring", stiffness: 300, damping: 30 }}
          />
          
          <div className="relative z-10 grid grid-cols-2 gap-1">
            {tabConfig.tabs.map((tab) => {
              const IconComponent = tab.icon;
              const isActive = currentActiveTab === tab.id;
              
              return (
                <motion.button
                  key={tab.id}
                  onClick={() => handleTabChange(tab.id)}
                  className={`flex items-center justify-center space-x-2 py-3 px-4 rounded-lg font-medium transition-colors ${
                    isActive
                      ? 'text-[var(--color-primary)]'
                      : 'text-[var(--color-text-muted)]'
                  }`}
                  whileTap={{ scale: 0.98 }}
                >
                  <IconComponent className="w-4 h-4" />
                  <span>{tab.label}</span>
                </motion.button>
              );
            })}
          </div>
        </div>
      </div>

      {/* Search Bar */}
      <div className="px-4 py-3">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4" style={{ color: 'var(--color-text-muted)' }} />
          <input
            type="text"
            placeholder={`Search ${currentActiveTab}...`}
            value={currentSearchTerm}
            onChange={(e) => handleSearch(e.target.value)}
            className="w-full pl-10 pr-4 py-2 bg-transparent border-0 border-b focus:outline-none transition-colors"
            style={{ 
              borderColor: 'var(--color-border)',
              color: 'var(--color-text)',
              backgroundColor: 'var(--color-bg)'
            }}
            onFocus={(e) => e.target.style.borderColor = 'var(--color-primary)'}
            onBlur={(e) => e.target.style.borderColor = 'var(--color-border)'}
          />
        </div>
      </div>

      {/* Main Content with improved transitions */}
      <div className="flex-1 overflow-hidden">
        <AnimatePresence mode="wait">
          {!showVariants ? (
            <motion.div
              key="category-list"
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: -20 }}
              transition={{ duration: 0.2 }}
              className="h-full overflow-y-auto"
            >
              {/* Categories with Dropdowns */}
              <div className="space-y-2 p-4">
                {Object.entries(CATEGORIES).map(([categoryKey, categoryInfo]) => {
                  const categoryComponents = componentsByCategory[categoryKey] || [];
                  const isExpanded = expandedCategories[categoryKey];
                  const hasComponents = categoryComponents.length > 0;
                  const CategoryIcon = categoryInfo.icon;

                  if (!hasComponents && currentSearchTerm) return null; // Hide empty categories when searching

                  return (
                    <div key={categoryKey} className="border rounded-lg overflow-hidden" style={{ borderColor: 'var(--color-border)' }}>
                      {/* Category Header */}
                      <button
                        onClick={() => toggleCategory(categoryKey)}
                        className="w-full flex items-center justify-between p-3 transition-all hover:opacity-80"
                        style={{ 
                          backgroundColor: hasComponents ? 'var(--color-surface)' : 'var(--color-bg-muted)',
                          opacity: hasComponents ? 1 : 0.5
                        }}
                        disabled={!hasComponents}
                      >
                        <div className="flex items-center gap-3">
                          <div 
                            className="w-8 h-8 rounded-lg flex items-center justify-center text-white font-bold"
                            style={{ backgroundColor: categoryInfo.color }}
                          >
                            <CategoryIcon className="w-4 h-4" />
                          </div>
                          <div className="text-left">
                            <div className="font-semibold text-sm" style={{ color: 'var(--color-text)' }}>
                              {categoryInfo.label}
                            </div>
                            <div className="text-xs" style={{ color: 'var(--color-text-muted)' }}>
                              {hasComponents ? `${categoryComponents.length} items` : 'No items'}
                            </div>
                          </div>
                        </div>
                        
                        <div className="flex items-center gap-2">
                          <span className="text-xs px-2 py-1 rounded-full" style={{ 
                            backgroundColor: hasComponents ? categoryInfo.color + '20' : 'var(--color-bg-muted)', 
                            color: hasComponents ? categoryInfo.color : 'var(--color-text-muted)'
                          }}>
                            {categoryComponents.length}
                          </span>
                          {hasComponents && (
                            <motion.div
                              animate={{ rotate: isExpanded ? 90 : 0 }}
                              transition={{ duration: 0.2 }}
                            >
                              <ChevronRight className="w-4 h-4" style={{ color: 'var(--color-text-muted)' }} />
                            </motion.div>
                          )}
                        </div>
                      </button>

                      {/* Category Content */}
                      <AnimatePresence>
                        {isExpanded && hasComponents && (
                          <motion.div
                            initial={{ height: 0, opacity: 0 }}
                            animate={{ height: 'auto', opacity: 1 }}
                            exit={{ height: 0, opacity: 0 }}
                            transition={{ duration: 0.3, ease: "easeOut" }}
                            className="overflow-hidden"
                          >
                            <div className="p-3 space-y-2" style={{ backgroundColor: 'var(--color-bg-muted)' }}>
                              {categoryComponents.map((component) => {
                                const IconComponent = iconMap[component.icon] || Square;
                                const variantCount = Array.isArray(component.variants) ? component.variants.length : 0;
                                
                                return (
                                  <motion.div
                                    key={component.id}
                                    className="group p-3 border-2 border-dashed rounded-xl cursor-pointer transition-all duration-200 hover:scale-[1.02]"
                                    style={{ 
                                      borderColor: 'var(--color-border)',
                                      backgroundColor: 'var(--color-surface)'
                                    }}
                                    onClick={() => handleComponentClick(component)}
                                    whileHover={{ scale: 1.01 }}
                                    whileTap={{ scale: 0.99 }}
                                    onMouseEnter={(e) => {
                                      e.currentTarget.style.borderColor = categoryInfo.color;
                                      e.currentTarget.style.boxShadow = `0 4px 20px ${categoryInfo.color}20`;
                                    }}
                                    onMouseLeave={(e) => {
                                      e.currentTarget.style.borderColor = 'var(--color-border)';
                                      e.currentTarget.style.boxShadow = 'none';
                                    }}
                                  >
                                    <div className="flex items-center gap-3">
                                      <div 
                                        className="w-10 h-10 rounded-lg flex items-center justify-center text-white font-bold"
                                        style={{ backgroundColor: categoryInfo.color }}
                                      >
                                        <IconComponent className="w-5 h-5" />
                                      </div>
                                      <div className="flex-1 min-w-0">
                                        <div className="font-semibold text-sm group-hover:opacity-80 transition-opacity" style={{ color: 'var(--color-text)' }}>
                                          {component.name}
                                        </div>
                                        <div className="text-xs" style={{ color: 'var(--color-text-muted)' }}>
                                          {component.description}
                                        </div>
                                        {variantCount > 0 && (
                                          <div className="mt-1 text-xs" style={{ color: categoryInfo.color }}>
                                            {variantCount} variant{variantCount !== 1 ? 's' : ''}
                                          </div>
                                        )}
                                      </div>
                                      <div className="w-2 h-2 rounded-full group-hover:scale-150 transition-transform" style={{ backgroundColor: categoryInfo.color }}></div>
                                    </div>
                                  </motion.div>
                                );
                              })}
                            </div>
                          </motion.div>
                        )}
                      </AnimatePresence>
                    </div>
                  );
                })}

                {/* Empty State */}
                {Object.values(componentsByCategory).every(category => category.length === 0) && (
                  <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    className="text-center py-12"
                  >
                    <div className="w-16 h-16 mx-auto mb-4 rounded-full flex items-center justify-center" style={{ backgroundColor: 'var(--color-bg-muted)' }}>
                      <Search className="w-8 h-8" style={{ color: 'var(--color-text-muted)' }} />
                    </div>
                    <div style={{ color: 'var(--color-text-muted)' }}>
                      {currentSearchTerm ? `No ${currentActiveTab} found for "${currentSearchTerm}"` : `No ${currentActiveTab} available`}
                    </div>
                  </motion.div>
                )}
              </div>
            </motion.div>
          ) : (
            <motion.div
              key={`variants-${selectedComponent?.id || 'none'}`}
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 20 }}
              transition={{ duration: 0.2 }}
              className="h-full overflow-hidden"
            >
              {/* Back Button */}
              <div className="p-3 border-b" style={{ borderColor: 'var(--color-border)' }}>
                <motion.button
                  onClick={handleBackClick}
                  className="flex items-center space-x-2 transition-colors hover:opacity-80"
                  style={{ color: 'var(--color-text-muted)' }}
                  whileHover={{ x: -2 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <ChevronRight className="w-4 h-4 rotate-180" />
                  <span className="text-sm">Back to {currentActiveTab}</span>
                </motion.button>
                
                <div className="mt-2">
                  <h3 className="font-semibold text-base" style={{ color: 'var(--color-text)' }}>
                    {selectedComponent?.name}
                  </h3>
                  <p className="text-xs" style={{ color: 'var(--color-text-muted)' }}>
                    {selectedComponent?.description}
                  </p>
                </div>
              </div>

              {/* Variants Grid */}
              <div className="flex-1 overflow-y-auto p-3">
                <motion.div
                  className="rounded-xl p-3"
                  style={{ backgroundColor: 'var(--color-bg-muted)' }}
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  transition={{ delay: 0.1 }}
                >
                  <div className="grid grid-cols-1 gap-2">
                    {selectedComponent?.variants?.map((variant, index) => (
                      <motion.div
                        key={`${selectedComponent.id}-${variant.name || index}`}
                        className="group relative"
                        initial={{ opacity: 0, y: 15 }}
                        animate={{ opacity: 1, y: 0 }}
                        transition={{ delay: index * 0.03 }}
                        draggable
                        onDragStart={(e) => handleVariantDragStart(e, selectedComponent, variant)}
                        onDragEnd={handleVariantDragEnd}
                      >
                        <div 
                          className="rounded-lg p-3 border transition-all duration-300 shadow-sm hover:shadow-lg relative overflow-hidden backdrop-blur-sm cursor-grab active:cursor-grabbing"
                          style={{ 
                            backgroundColor: 'var(--color-surface)',
                            borderColor: 'var(--color-border)'
                          }}
                          onMouseEnter={(e) => {
                            e.currentTarget.style.borderColor = 'var(--color-primary)';
                            e.currentTarget.style.transform = 'translateY(-2px)';
                          }}
                          onMouseLeave={(e) => {
                            e.currentTarget.style.borderColor = 'var(--color-border)';
                            e.currentTarget.style.transform = 'translateY(0px)';
                          }}
                        >
                          <div className="flex items-start gap-3 w-full min-w-0 relative z-10">
                            {/* Variant Preview */}
                            <div 
                              className="flex-shrink-0 rounded-lg overflow-hidden flex items-center justify-center border cursor-grab active:cursor-grabbing"
                              style={{ 
                                background: `linear-gradient(135deg, var(--color-bg-muted), var(--color-surface))`,
                                width: '56px',
                                height: '40px',
                                borderColor: 'var(--color-border)'
                              }}
                              draggable
                              onDragStart={(e) => handleVariantDragStart(e, selectedComponent, variant)}
                              onDragEnd={handleVariantDragEnd}
                              title="Drag this component to canvas"
                            >
                              {variant.preview_code && (
                                <div 
                                  className="transform scale-[0.4] origin-center w-full h-full flex items-center justify-center"
                                  style={{ fontSize: '10px' }}
                                  dangerouslySetInnerHTML={{ 
                                    __html: variant.preview_code.replace(/className=/g, 'class=') 
                                  }}
                                />
                              )}
                              {!variant.preview_code && (
                                <Sparkles 
                                  className="w-4 h-4"
                                  style={{ color: 'var(--color-primary)' }}
                                />
                              )}
                              
                              <div className="absolute top-0 right-0 opacity-0 hover:opacity-100 transition-all duration-300">
                                <div 
                                  className="p-1 rounded-full"
                                  style={{ backgroundColor: 'var(--color-primary)' }}
                                >
                                  <Move className="w-2 h-2 text-white" />
                                </div>
                              </div>
                            </div>
                            
                            {/* Variant Info */}
                            <div className="flex-1 min-w-0">
                              <div className="flex items-center justify-between mb-1">
                                <h4 
                                  className="font-semibold text-sm group-hover:opacity-90 transition-colors truncate"
                                  style={{ color: 'var(--color-text)' }}
                                  title={variant.name || `Variant ${index + 1}`}
                                >
                                  {variant.name || `Variant ${index + 1}`}
                                </h4>
                              </div>
                              
                              {variant.description && (
                                <p className="text-xs mb-2 truncate" style={{ color: 'var(--color-text-muted)' }}>
                                  {variant.description}
                                </p>
                              )}
                            </div>
                          </div>
                        </div>
                      </motion.div>
                    ))}
                  </div>
                  
                  {(!selectedComponent?.variants || selectedComponent.variants.length === 0) && (
                    <div className="text-center py-8">
                      <div style={{ color: 'var(--color-text-muted)' }}>
                        No variants available for this component
                      </div>
                    </div>
                  )}
                </motion.div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
};

export default ComponentsPanel;



/* @/css/forge.css - Enhanced CSS for Forge Page Components */

/* Enhanced drag styles with CSS variables */
.drag-preview {
  animation: dragBounce 0.3s ease-out;
  backdrop-filter: blur(20px);
}

@keyframes dragBounce {
  0% { transform: scale(1) rotate(0deg); }
  50% { transform: scale(1.1) rotate(2deg); }
  100% { transform: scale(1) rotate(2deg); }
}

.canvas-container {
  position: relative;
  width: 100%;
  height: 100%;
  min-height: 400px;
}

/* Enhanced Code syntax highlighting styles */
.code-keyword {
  color: #569cd6;
  font-weight: 600;
  cursor: help;
  border-radius: 3px;
  padding: 1px 2px;
  margin: -1px -2px;
  transition: background-color 0.2s ease;
}

.code-keyword:hover {
  background-color: rgba(86, 156, 214, 0.2);
}

.code-string {
  color: #ce9178;
  cursor: help;
  border-radius: 3px;
  padding: 1px 2px;
  margin: -1px -2px;
  transition: background-color 0.2s ease;
}

.code-string:hover {
  background-color: rgba(206, 145, 120, 0.2);
}

.code-comment {
  color: #6a9955;
  font-style: italic;
}

.code-tag {
  color: #4ec9b0;
  cursor: help;
  border-radius: 3px;
  padding: 1px 2px;
  margin: -1px -2px;
  transition: background-color 0.2s ease;
}

.code-tag:hover {
  background-color: rgba(78, 201, 176, 0.2);
}

.code-attr {
  color: #9cdcfe;
  cursor: help;
  border-radius: 3px;
  padding: 1px 2px;
  margin: -1px -2px;
  transition: background-color 0.2s ease;
}

.code-attr:hover {
  background-color: rgba(156, 220, 254, 0.2);
}

.code-number {
  color: #b5cea8;
}

.code-function {
  color: #dcdcaa;
  cursor: help;
  border-radius: 3px;
  padding: 1px 2px;
  margin: -1px -2px;
  transition: background-color 0.2s ease;
}

.code-function:hover {
  background-color: rgba(220, 220, 170, 0.2);
}

.code-property {
  color: #9cdcfe;
  cursor: help;
  border-radius: 3px;
  padding: 1px 2px;
  margin: -1px -2px;
  transition: background-color 0.2s ease;
}

.code-property:hover {
  background-color: rgba(156, 220, 254, 0.2);
}

.code-value {
  color: #ce9178;
}

.code-selector {
  color: #d7ba7d;
}

/* Tailwind-specific highlighting */
.code-tailwind {
  cursor: help;
  border-radius: 3px;
  padding: 1px 3px;
  margin: -1px -3px;
  transition: all 0.2s ease;
  font-weight: 500;
}

.code-tailwind.layout {
  color: #f59e0b;
}

.code-tailwind.layout:hover {
  background-color: rgba(245, 158, 11, 0.2);
}

.code-tailwind.spacing {
  color: #ec4899;
}

.code-tailwind.spacing:hover {
  background-color: rgba(236, 72, 153, 0.2);
}

.code-tailwind.sizing {
  color: #8b5cf6;
}

.code-tailwind.sizing:hover {
  background-color: rgba(139, 92, 246, 0.2);
}

.code-tailwind.color {
  color: #06b6d4;
}

.code-tailwind.color:hover {
  background-color: rgba(6, 182, 212, 0.2);
}

.code-tailwind.decoration {
  color: #10b981;
}

.code-tailwind.decoration:hover {
  background-color: rgba(16, 185, 129, 0.2);
}

.code-tailwind.effects {
  color: #f97316;
}

.code-tailwind.effects:hover {
  background-color: rgba(249, 115, 22, 0.2);
}

.code-tailwind.interaction {
  color: #ef4444;
}

.code-tailwind.interaction:hover {
  background-color: rgba(239, 68, 68, 0.2);
}

/* Enhanced scrollbar for code editor */
.code-editor::-webkit-scrollbar {
  width: 12px;
}

.code-editor::-webkit-scrollbar-track {
  background: #2d3748;
  border-radius: 6px;
}

.code-editor::-webkit-scrollbar-thumb {
  background: var(--color-primary);
  border-radius: 6px;
  border: 2px solid #2d3748;
}

.code-editor::-webkit-scrollbar-thumb:hover {
  background: var(--color-primary-hover);
}

/* Fixed bottom panel specific styles */
.fixed-code-panel {
  backdrop-filter: blur(20px);
  border-top: 2px solid var(--color-border);
}

/* Resizable handle styles */
.resize-handle {
  background: linear-gradient(to right, transparent, var(--color-primary), transparent);
  opacity: 0.5;
  transition: opacity 0.2s ease;
}

.resize-handle:hover {
  opacity: 1;
}

/* Smooth transitions for all interactive elements */
.group:hover .group-hover\:scale-110 {
  transform: scale(1.1);
}

/* Focus styles using CSS variables */
input:focus, textarea:focus, button:focus {
  box-shadow: 0 0 0 3px rgba(160, 82, 255, 0.1);
  border-color: var(--color-primary) !important;
}

/* Hover effects */
[style*="cursor-pointer"]:hover {
  transform: translateY(-1px);
  transition: var(--transition);
}

/* Selection styles */
::selection {
  background-color: var(--color-primary-soft);
  color: var(--color-primary);
}

/* Professional button styles */
button {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  font-weight: 500;
  letter-spacing: -0.025em;
}

/* Enhanced input styles */
input, textarea, select {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  transition: var(--transition);
}

input:hover, textarea:hover, select:hover {
  border-color: var(--color-primary-hover);
}

/* Professional panel styling with full opacity */
[class*="panel"] {
  backdrop-filter: blur(20px);
  border: 1px solid var(--color-border);
  opacity: 1 !important;
}

/* Ensure sidebar code panel has full opacity */
.panel-content .code-editor {
  opacity: 1 !important;
}

.panel-content .code-editor * {
  opacity: 1 !important;
}

/* Loading states */
.loading {
  position: relative;
  overflow: hidden;
}

.loading::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0% { left: -100%; }
  100% { left: 100%; }
}

/* Toast notification styles */
.toast {
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  backdrop-filter: blur(20px);
}

/* Professional animations */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeInScale {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.animate-fadeInUp {
  animation: fadeInUp 0.3s ease-out;
}

.animate-fadeInScale {
  animation: fadeInScale 0.2s ease-out;
}

/* Enhanced mobile responsiveness */
@media (max-width: 768px) {
  .tooltip {
    font-size: 11px;
    max-width: 250px;
  }
  
  .code-editor {
    font-size: 12px;
  }
  
  .fixed-code-panel {
    left: 0 !important;
    right: 0 !important;
  }
}

/* Touch-friendly hover states */
@media (hover: none) {
  .code-keyword,
  .code-string,
  .code-tag,
  .code-attr,
  .code-function,
  .code-property,
  .code-tailwind {
    cursor: pointer;
  }
  
  .code-keyword:active,
  .code-string:active,
  .code-tag:active,
  .code-attr:active,
  .code-function:active,
  .code-property:active,
  .code-tailwind:active {
    background-color: rgba(255, 255, 255, 0.1) !important;
  }
}

/* Code formatting improvements */
.code-editor pre {
  tab-size: 2;
  -moz-tab-size: 2;
  -o-tab-size: 2;
  white-space: pre-wrap;
  word-wrap: break-word;
}

/* Better line height for readability */
.code-editor,
.code-editor pre,
.code-editor textarea {
  line-height: 1.6 !important;
}

/* Ensure consistent font sizing */
.code-editor * {
  font-family: Monaco, Menlo, "Ubuntu Mono", "Courier New", monospace !important;
}



/* Add to resources/css/forge.css */

/* Empty canvas state animations */
.empty-canvas-pulse {
  animation: emptyCanvasPulse 3s ease-in-out infinite;
}

@keyframes emptyCanvasPulse {
  0%, 100% { border-color: #d1d5db; }
  50% { border-color: #3b82f6; }
}

/* Section drop zone styles */
.section-drop-zone {
  transition: all 0.2s ease;
}

.section-drop-zone.active {
  border-color: #3b82f6;
  background-color: rgba(59, 130, 246, 0.1);
  box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
}

/* Layout element placeholder styles */
.layout-placeholder {
  min-height: 100px;
  border: 2px dashed #e5e7eb;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #6b7280;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.2s ease;
}

.layout-placeholder:hover {
  border-color: #3b82f6;
  background-color: rgba(59, 130, 246, 0.05);
}

/* Page structure hierarchy indicators */
.page-structure-hint {
  border-left: 4px solid #e5e7eb;
  padding-left: 12px;
  margin: 8px 0;
}

.page-structure-hint.section {
  border-left-color: #10b981;
}

.page-structure-hint.component {
  border-left-color: #3b82f6;
}


/* Enhanced layout container styles */
.layout-container {
  min-height: 100px;
  transition: all 0.2s ease;
  position: relative;
}

.layout-container[data-is-layout="true"]:hover {
  outline: 2px dashed rgba(59, 130, 246, 0.3);
  outline-offset: 2px;
}

.layout-container[data-is-layout="true"]:hover::before {
  content: attr(data-component-id);
  position: absolute;
  top: -20px;
  left: 0;
  font-size: 10px;
  background: rgba(59, 130, 246, 0.9);
  color: white;
  padding: 2px 6px;
  border-radius: 3px;
  font-family: monospace;
  z-index: 100;
  pointer-events: none;
}

/* Nested depth indicators */
.layout-container[data-depth="0"] {
  border: 2px solid transparent;
}

.layout-container[data-depth="1"] {
  border-left: 3px solid rgba(139, 92, 246, 0.3);
}

.layout-container[data-depth="2"] {
  border-left: 3px solid rgba(236, 72, 153, 0.3);
}

.layout-container[data-depth="3"] {
  border-left: 3px solid rgba(34, 197, 94, 0.3);
}

/* Touch-friendly drag handle */
@media (hover: none) {
  [class*="drag-handle"] {
    opacity: 1 !important;
    transform: scale(1.2);
  }
}

/* Long press animation */
@keyframes longPressGlow {
  0%, 100% { box-shadow: 0 0 0 0 rgba(160, 82, 255, 0.4); }
  50% { box-shadow: 0 0 0 8px rgba(160, 82, 255, 0); }
}

.long-press-active {
  animation: longPressGlow 1.5s ease-in-out infinite;
}




.dragging {
  opacity: 0.5;
  border: 2px dashed var(--color-primary);
}

.drag-over {
  border-top: 3px solid var(--color-primary);
}







/* Smooth drag cursor */
.cursor-grabbing * {
  cursor: grabbing !important;
}

[data-component-id]:active {
  cursor: grabbing !important;
}

/* Long press visual feedback */
@keyframes long-press-glow {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7);
  }
  50% {
    box-shadow: 0 0 0 15px rgba(139, 92, 246, 0);
  }
}




/* Enhanced drag and drop styles */
.canvas-no-select * {
  user-select: none !important;
  -webkit-user-select: none !important;
  -webkit-touch-callout: none !important;
  -moz-user-select: none !important;
  -ms-user-select: none !important;
}

.dragging-component {
  opacity: 0.3 !important;
  pointer-events: none !important;
  transition: opacity 0.2s ease !important;
}

.drag-ghost {
  position: fixed !important;
  z-index: 99999 !important;
  pointer-events: none !important;
  opacity: 0.9 !important;
  transform: scale(1.05) !important;
  box-shadow: 0 25px 70px rgba(0,0,0,0.4) !important;
  animation: dragFloat 0.5s ease-in-out infinite alternate !important;
}

@keyframes dragFloat {
  from {
    transform: scale(1.05) translateY(0px) rotate(2deg);
  }
  to {
    transform: scale(1.08) translateY(-5px) rotate(3deg);
  }
}

/* Long press glow animation */
@keyframes long-press-glow {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7);
  }
  50% {
    box-shadow: 0 0 0 15px rgba(139, 92, 246, 0);
  }
}

.long-press-active {
  animation: long-press-glow 1s ease-in-out !important;
  border-color: rgba(139, 92, 246, 0.8) !important;
}

/* Touch-friendly drag handles */
[data-component-id] {
  touch-action: none;
  -webkit-user-drag: element;
}

[data-component-id]:active {
  cursor: grabbing !important;
}

/* Smooth transitions for space adjustments */
[data-is-layout="true"] {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}


// @/Components/Forge/SelectionOverlay.jsx
import React, { useState, useEffect } from 'react';
import { useEditorStore } from '@/stores/useEditorStore'; // ADD THIS

const SelectionOverlay = ({ componentId, canvasRef }) => {
  const [bounds, setBounds] = useState(null);
  const [computedStyles, setComputedStyles] = useState(null);
  
  // GET responsive mode and scale factor
  const { responsiveMode, getResponsiveScaleFactor } = useEditorStore();

     // REPLACE the useEffect in SelectionOverlay.jsx (around line 8-60)
  useEffect(() => {
    if (!componentId || !canvasRef.current) return;
  
    const updateBounds = () => {
      const element = document.querySelector(`[data-component-id="${componentId}"]`);
      if (!element) {
        setBounds(null);
        setComputedStyles(null);
        return;
      }
  
      const rect = element.getBoundingClientRect();
      const canvasRect = canvasRef.current.getBoundingClientRect();
      const styles = window.getComputedStyle(element);
  
      // Get actual scale from canvas transform or use responsive scale
      let scaleFactor = 1;
      
      if (responsiveMode !== 'desktop') {
        scaleFactor = getResponsiveScaleFactor();
      }
      
      const canvasTransform = window.getComputedStyle(canvasRef.current).transform;
      if (canvasTransform && canvasTransform !== 'none') {
        const matrix = new DOMMatrix(canvasTransform);
        scaleFactor = matrix.a;
      }
  
      setBounds({
        top: (rect.top - canvasRect.top) / scaleFactor,
        left: (rect.left - canvasRect.left) / scaleFactor,
        width: rect.width / scaleFactor,
        height: rect.height / scaleFactor
      });
  
      setComputedStyles({
        marginTop: parseInt(styles.marginTop) || 0,
        marginRight: parseInt(styles.marginRight) || 0,
        marginBottom: parseInt(styles.marginBottom) || 0,
        marginLeft: parseInt(styles.marginLeft) || 0,
        paddingTop: parseInt(styles.paddingTop) || 0,
        paddingRight: parseInt(styles.paddingRight) || 0,
        paddingBottom: parseInt(styles.paddingBottom) || 0,
        paddingLeft: parseInt(styles.paddingLeft) || 0
      });
    };
  
    // Immediate update
    updateBounds();
    
    const element = document.querySelector(`[data-component-id="${componentId}"]`);
    if (!element) return;
    
    // Watch for size changes
    const resizeObserver = new ResizeObserver(() => {
      requestAnimationFrame(updateBounds);
    });
    resizeObserver.observe(element);
    
    // ADDED: Watch for attribute/style changes
    const mutationObserver = new MutationObserver((mutations) => {
      const hasStyleChange = mutations.some(m => 
        m.type === 'attributes' && (m.attributeName === 'style' || m.attributeName === 'class')
      );
      if (hasStyleChange) {
        requestAnimationFrame(updateBounds);
      }
    });
    
    mutationObserver.observe(element, {
      attributes: true,
      attributeFilter: ['style', 'class']
    });
    
    // Listen for responsive mode changes
    const handleModeChange = () => {
      setBounds(null);
      setComputedStyles(null);
      setTimeout(updateBounds, 150);
    };
    
    window.addEventListener('responsive-mode-changed', handleModeChange);
  
    return () => {
      resizeObserver.disconnect();
      mutationObserver.disconnect();
      window.removeEventListener('responsive-mode-changed', handleModeChange);
    };
  }, [componentId, canvasRef, responsiveMode, getResponsiveScaleFactor]);

  if (!bounds || !computedStyles) return null;

  // Calculate content area (after padding is applied)
  const contentArea = {
    top: bounds.top + computedStyles.paddingTop,
    left: bounds.left + computedStyles.paddingLeft,
    width: bounds.width - computedStyles.paddingLeft - computedStyles.paddingRight,
    height: bounds.height - computedStyles.paddingTop - computedStyles.paddingBottom
  };

  return (
    <div className="absolute inset-0 pointer-events-none z-40" style={{ overflow: 'visible' }}>
      {/* Margin Overlay - Orange */}
      {(computedStyles.marginTop > 0 || computedStyles.marginRight > 0 || 
        computedStyles.marginBottom > 0 || computedStyles.marginLeft > 0) && (
        <>
          {/* Top Margin */}
          {computedStyles.marginTop > 0 && (
            <div
              className="absolute"
              style={{
                top: bounds.top - computedStyles.marginTop,
                left: bounds.left,
                width: bounds.width,
                height: computedStyles.marginTop,
                backgroundColor: 'rgba(251, 146, 60, 0.15)',
                borderTop: '1px dashed rgba(251, 146, 60, 0.5)',
                borderBottom: '1px dashed rgba(251, 146, 60, 0.5)'
              }}
            >
              <span className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-[10px] font-mono bg-orange-500 text-white px-1.5 py-0.5 rounded shadow-sm">
                {computedStyles.marginTop}
              </span>
            </div>
          )}

          {/* Right Margin */}
          {computedStyles.marginRight > 0 && (
            <div
              className="absolute"
              style={{
                top: bounds.top,
                left: bounds.left + bounds.width,
                width: computedStyles.marginRight,
                height: bounds.height,
                backgroundColor: 'rgba(251, 146, 60, 0.15)',
                borderLeft: '1px dashed rgba(251, 146, 60, 0.5)',
                borderRight: '1px dashed rgba(251, 146, 60, 0.5)'
              }}
            >
              <span className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-[10px] font-mono bg-orange-500 text-white px-1.5 py-0.5 rounded shadow-sm">
                {computedStyles.marginRight}
              </span>
            </div>
          )}

          {/* Bottom Margin */}
          {computedStyles.marginBottom > 0 && (
            <div
              className="absolute"
              style={{
                top: bounds.top + bounds.height,
                left: bounds.left,
                width: bounds.width,
                height: computedStyles.marginBottom,
                backgroundColor: 'rgba(251, 146, 60, 0.15)',
                borderTop: '1px dashed rgba(251, 146, 60, 0.5)',
                borderBottom: '1px dashed rgba(251, 146, 60, 0.5)'
              }}
            >
              <span className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-[10px] font-mono bg-orange-500 text-white px-1.5 py-0.5 rounded shadow-sm">
                {computedStyles.marginBottom}
              </span>
            </div>
          )}

          {/* Left Margin */}
          {computedStyles.marginLeft > 0 && (
            <div
              className="absolute"
              style={{
                top: bounds.top,
                left: bounds.left - computedStyles.marginLeft,
                width: computedStyles.marginLeft,
                height: bounds.height,
                backgroundColor: 'rgba(251, 146, 60, 0.15)',
                borderLeft: '1px dashed rgba(251, 146, 60, 0.5)',
                borderRight: '1px dashed rgba(251, 146, 60, 0.5)'
              }}
            >
              <span className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-[10px] font-mono bg-orange-500 text-white px-1.5 py-0.5 rounded shadow-sm">
                {computedStyles.marginLeft}
              </span>
            </div>
          )}
        </>
      )}

      {/* Padding Overlay - Green */}
      {(computedStyles.paddingTop > 0 || computedStyles.paddingRight > 0 || 
        computedStyles.paddingBottom > 0 || computedStyles.paddingLeft > 0) && (
        <>
          {/* Top Padding */}
          {computedStyles.paddingTop > 0 && (
            <div
              className="absolute"
              style={{
                top: bounds.top,
                left: bounds.left,
                width: bounds.width,
                height: computedStyles.paddingTop,
                backgroundColor: 'rgba(34, 197, 94, 0.15)',
                borderTop: '1px dashed rgba(34, 197, 94, 0.5)',
                borderBottom: '1px dashed rgba(34, 197, 94, 0.5)'
              }}
            >
              <span className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-[10px] font-mono bg-green-500 text-white px-1.5 py-0.5 rounded shadow-sm">
                {computedStyles.paddingTop}
              </span>
            </div>
          )}

          {/* Right Padding */}
          {computedStyles.paddingRight > 0 && (
            <div
              className="absolute"
              style={{
                top: bounds.top,
                left: bounds.left + bounds.width - computedStyles.paddingRight,
                width: computedStyles.paddingRight,
                height: bounds.height,
                backgroundColor: 'rgba(34, 197, 94, 0.15)',
                borderLeft: '1px dashed rgba(34, 197, 94, 0.5)',
                borderRight: '1px dashed rgba(34, 197, 94, 0.5)'
              }}
            >
              <span className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-[10px] font-mono bg-green-500 text-white px-1.5 py-0.5 rounded shadow-sm">
                {computedStyles.paddingRight}
              </span>
            </div>
          )}

          {/* Bottom Padding */}
          {computedStyles.paddingBottom > 0 && (
            <div
              className="absolute"
              style={{
                top: bounds.top + bounds.height - computedStyles.paddingBottom,
                left: bounds.left,
                width: bounds.width,
                height: computedStyles.paddingBottom,
                backgroundColor: 'rgba(34, 197, 94, 0.15)',
                borderTop: '1px dashed rgba(34, 197, 94, 0.5)',
                borderBottom: '1px dashed rgba(34, 197, 94, 0.5)'
              }}
            >
              <span className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-[10px] font-mono bg-green-500 text-white px-1.5 py-0.5 rounded shadow-sm">
                {computedStyles.paddingBottom}
              </span>
            </div>
          )}

          {/* Left Padding */}
          {computedStyles.paddingLeft > 0 && (
            <div
              className="absolute"
              style={{
                top: bounds.top,
                left: bounds.left,
                width: computedStyles.paddingLeft,
                height: bounds.height,
                backgroundColor: 'rgba(34, 197, 94, 0.15)',
                borderLeft: '1px dashed rgba(34, 197, 94, 0.5)',
                borderRight: '1px dashed rgba(34, 197, 94, 0.5)'
              }}
            >
              <span className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-[10px] font-mono bg-green-500 text-white px-1.5 py-0.5 rounded shadow-sm">
                {computedStyles.paddingLeft}
              </span>
            </div>
          )}

          {/* Content Area Border */}
          <div
            className="absolute border border-dashed"
            style={{
              top: contentArea.top,
              left: contentArea.left,
              width: contentArea.width,
              height: contentArea.height,
              borderColor: 'rgba(59, 130, 246, 0.5)',
              pointerEvents: 'none'
            }}
          >
            <span className="absolute -top-5 left-0 text-[9px] font-mono bg-blue-500 text-white px-1.5 py-0.5 rounded shadow-sm whitespace-nowrap">
              {Math.round(contentArea.width)} × {Math.round(contentArea.height)}
            </span>
          </div>
        </>
      )}
    </div>
  );
};

export default SelectionOverlay;



// resources/js/Components/Forge/SectionDropZone.jsx
import React from 'react';
import { Plus, Layout } from 'lucide-react';

const SectionDropZone = ({ 
  position, 
  onDrop, 
  onDragOver, 
  onDragLeave, 
  isDragOver = false,
  isVisible = true 
}) => {
  if (!isVisible) return null;

  const positionClasses = {
    top: 'top-0 -translate-y-1/2',
    bottom: 'bottom-0 translate-y-1/2',
    between: 'top-1/2 -translate-y-1/2'
  };

  return (
    <div 
      className={`
        absolute left-0 right-0 h-16 z-20 transition-all duration-200
        ${positionClasses[position]}
        ${isDragOver ? 'opacity-100' : 'opacity-0 hover:opacity-100'}
      `}
      onDrop={onDrop}
      onDragOver={onDragOver}
      onDragLeave={onDragLeave}
    >
      <div className={`
        w-full h-full border-2 border-dashed rounded-lg flex items-center justify-center
        transition-all duration-200
        ${isDragOver 
          ? 'border-blue-500 bg-blue-50 shadow-lg' 
          : 'border-gray-300 bg-gray-50 hover:border-blue-400 hover:bg-blue-25'
        }
      `}>
        <div className="flex items-center gap-2 text-sm font-medium text-gray-600">
          <Plus className="w-4 h-4" />
          <span>Drop Section Here</span>
          <Layout className="w-4 h-4" />
        </div>
      </div>
    </div>
  );
};

export default SectionDropZone;



// @/Components/Forge/DragSnapLines.jsx
import React from 'react';

const DragSnapLines = ({ dragPosition, canvasComponents, canvasRef }) => {
  if (!dragPosition || !canvasRef.current) return null;

  const snapThreshold = 5; // pixels
  const snapLines = [];
  
  const canvasRect = canvasRef.current.getBoundingClientRect();
  
  // Check snap points against all components
  canvasComponents.forEach(comp => {
    const element = document.querySelector(`[data-component-id="${comp.id}"]`);
    if (!element) return;

    const rect = element.getBoundingClientRect();
    const relativeRect = {
      top: rect.top - canvasRect.top,
      left: rect.left - canvasRect.left,
      right: rect.right - canvasRect.left,
      bottom: rect.bottom - canvasRect.top,
      centerX: (rect.left + rect.right) / 2 - canvasRect.left,
      centerY: (rect.top + rect.bottom) / 2 - canvasRect.top
    };

    // Vertical snap lines
    if (Math.abs(dragPosition.x - relativeRect.left) < snapThreshold) {
      snapLines.push({ type: 'vertical', position: relativeRect.left, label: '0px' });
    }
    if (Math.abs(dragPosition.x - relativeRect.right) < snapThreshold) {
      snapLines.push({ type: 'vertical', position: relativeRect.right, label: '0px' });
    }
    if (Math.abs(dragPosition.x - relativeRect.centerX) < snapThreshold) {
      snapLines.push({ type: 'vertical', position: relativeRect.centerX, label: 'center' });
    }

    // Horizontal snap lines
    if (Math.abs(dragPosition.y - relativeRect.top) < snapThreshold) {
      snapLines.push({ type: 'horizontal', position: relativeRect.top, label: '0px' });
    }
    if (Math.abs(dragPosition.y - relativeRect.bottom) < snapThreshold) {
      snapLines.push({ type: 'horizontal', position: relativeRect.bottom, label: '0px' });
    }
    if (Math.abs(dragPosition.y - relativeRect.centerY) < snapThreshold) {
      snapLines.push({ type: 'horizontal', position: relativeRect.centerY, label: 'center' });
    }

    // Gap measurements
    const gap = Math.abs(dragPosition.y - relativeRect.bottom);
    if (gap > 0 && gap < 50) {
      snapLines.push({
        type: 'gap-vertical',
        start: relativeRect.bottom,
        end: dragPosition.y,
        label: `${Math.round(gap)}px`
      });
    }
  });

  return (
    <div className="absolute inset-0 pointer-events-none z-50">
      {snapLines.map((line, idx) => {
        if (line.type === 'vertical') {
          return (
            <div
              key={`v-${idx}`}
              className="absolute w-px bg-blue-500"
              style={{
                left: line.position,
                top: 0,
                bottom: 0,
                boxShadow: '0 0 4px rgba(59, 130, 246, 0.5)'
              }}
            >
              <span className="absolute top-2 left-2 text-xs font-mono bg-blue-500 text-white px-1 rounded">
                {line.label}
              </span>
            </div>
          );
        }
        
        if (line.type === 'horizontal') {
          return (
            <div
              key={`h-${idx}`}
              className="absolute h-px bg-blue-500"
              style={{
                top: line.position,
                left: 0,
                right: 0,
                boxShadow: '0 0 4px rgba(59, 130, 246, 0.5)'
              }}
            >
              <span className="absolute left-2 top-2 text-xs font-mono bg-blue-500 text-white px-1 rounded">
                {line.label}
              </span>
            </div>
          );
        }

        if (line.type === 'gap-vertical') {
          return (
            <div
              key={`gap-${idx}`}
              className="absolute"
              style={{
                left: dragPosition.x + 20,
                top: Math.min(line.start, line.end),
                height: Math.abs(line.end - line.start)
              }}
            >
              <div className="relative h-full w-px bg-purple-500">
                <div className="absolute top-0 w-2 h-px bg-purple-500 -left-0.5"></div>
                <div className="absolute bottom-0 w-2 h-px bg-purple-500 -left-0.5"></div>
                <span className="absolute top-1/2 -translate-y-1/2 left-2 text-xs font-mono bg-purple-500 text-white px-1 rounded whitespace-nowrap">
                  {line.label}
                </span>
              </div>
            </div>
          );
        }

        return null;
      })}
    </div>
  );
};

export default DragSnapLines;




<?php
// app/Http/Controllers/ComponentController.php
namespace App\Http\Controllers;

use App\Models\Component;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;

class ComponentController extends Controller
{
    public function index(): JsonResponse
    {
        try {
            $components = Component::active()
                ->ordered()
                ->get();

            // Debug: Log the raw components
            \Log::info('Raw components from database:', ['count' => $components->count()]);
            
            if ($components->isEmpty()) {
                \Log::warning('No components found in database');
                return response()->json([
                    'success' => true,
                    'data' => [
                        'elements' => [],
                        'components' => []
                    ],
                    'debug' => 'No components found in database'
                ]);
            }

            // Group by component_type first, then by alphabet_group
            $groupedComponents = $components->groupBy(function ($component) {
                $componentType = $component->component_type ?? 'element';
                $alphabetGroup = $component->alphabet_group ?? strtoupper(substr($component->name ?? 'A', 0, 1));
                return $componentType . '_' . $alphabetGroup;
            })->map(function ($group) {
                return $group->sortBy('sort_order')->values()->map(function ($component) {
                    // Ensure variants is properly handled
                    $variants = $component->variants;
                    if (is_string($variants)) {
                        $variants = json_decode($variants, true);
                    }
                    
                    return [
                        'id' => $component->id,
                        'name' => $component->name,
                        'type' => $component->type,
                        'component_type' => $component->component_type,
                        'category' => $component->category,
                        'alphabet_group' => $component->alphabet_group,
                        'description' => $component->description,
                        'icon' => $component->icon,
                        'default_props' => $component->default_props,
                        'prop_definitions' => $component->prop_definitions,
                        'variants' => $variants,
                        'has_animation' => $component->has_animation,
                        'animation_type' => $component->animation_type,
                        'sort_order' => $component->sort_order
                    ];
                });
            });

            // Restructure the data for frontend consumption
            $restructured = [
                'elements' => [],
                'components' => []
            ];

            foreach ($groupedComponents as $key => $group) {
                $parts = explode('_', $key);
                if (count($parts) >= 2) {
                    $type = $parts[0];
                    $letter = $parts[1];
                    
                    // Ensure the type key exists and is pluralized
                    $typeKey = $type === 'element' ? 'elements' : 'components';
                    
                    if (!isset($restructured[$typeKey])) {
                        $restructured[$typeKey] = [];
                    }
                    
                    if (!isset($restructured[$typeKey][$letter])) {
                        $restructured[$typeKey][$letter] = [];
                    }
                    
                    $restructured[$typeKey][$letter] = array_merge(
                        $restructured[$typeKey][$letter], 
                        $group->toArray()
                    );
                }
            }

            // Debug: Log the restructured data
            \Log::info('Restructured components:', [
                'elements_count' => count($restructured['elements']),
                'components_count' => count($restructured['components']),
                'elements_letters' => array_keys($restructured['elements']),
                'components_letters' => array_keys($restructured['components'])
            ]);

            return response()->json([
                'success' => true,
                'data' => $restructured,
                'debug' => [
                    'total_components' => $components->count(),
                    'elements_letters' => array_keys($restructured['elements']),
                    'components_letters' => array_keys($restructured['components'])
                ]
            ]);
            
        } catch (\Exception $e) {
            \Log::error('Error in ComponentController@index:', [
                'message' => $e->getMessage(),
                'file' => $e->getFile(),
                'line' => $e->getLine()
            ]);
            
            return response()->json([
                'success' => false,
                'message' => 'Failed to load components: ' . $e->getMessage(),
                'error' => $e->getMessage()
            ], 500);
        }
    }

    public function show(Component $component): JsonResponse
    {
        try {
            // Ensure variants is properly loaded and decoded
            $componentData = $component->toArray();
            
            if (isset($componentData['variants']) && is_string($componentData['variants'])) {
                $componentData['variants'] = json_decode($componentData['variants'], true);
            }
            
            return response()->json([
                'success' => true,
                'data' => $componentData
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to load component: ' . $e->getMessage()
            ], 500);
        }
    }

    public function store(Request $request): JsonResponse
    {
        try {
            $validated = $request->validate([
                'name' => 'required|string|max:255',
                'type' => 'required|string|unique:components|max:255',
                'component_type' => 'required|in:element,component',
                'category' => 'required|string|max:255',
                'alphabet_group' => 'required|string|size:1',
                'description' => 'required|string',
                'icon' => 'nullable|string|max:255',
                'default_props' => 'required|array',
                'prop_definitions' => 'required|array',
                'render_template' => 'required|string',
                'code_generators' => 'required|array',
                'variants' => 'nullable|array',
                'has_animation' => 'boolean',
                'animation_type' => 'nullable|string|max:255',
                'sort_order' => 'integer|min:0'
            ]);

            $component = Component::create($validated);

            return response()->json([
                'success' => true,
                'data' => $component,
                'message' => 'Component created successfully'
            ], 201);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to create component: ' . $e->getMessage()
            ], 500);
        }
    }

    public function update(Request $request, Component $component): JsonResponse
    {
        try {
            $validated = $request->validate([
                'name' => 'string|max:255',
                'type' => 'string|unique:components,type,' . $component->id . '|max:255',
                'component_type' => 'in:element,component',
                'category' => 'string|max:255',
                'alphabet_group' => 'string|size:1',
                'description' => 'string',
                'icon' => 'nullable|string|max:255',
                'default_props' => 'array',
                'prop_definitions' => 'array',
                'render_template' => 'string',
                'code_generators' => 'array',
                'variants' => 'nullable|array',
                'has_animation' => 'boolean',
                'animation_type' => 'nullable|string|max:255',
                'is_active' => 'boolean',
                'sort_order' => 'integer|min:0'
            ]);

            $component->update($validated);

            return response()->json([
                'success' => true,
                'data' => $component,
                'message' => 'Component updated successfully'
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to update component: ' . $e->getMessage()
            ], 500);
        }
    }

    public function destroy(Component $component): JsonResponse
    {
        try {
            $component->delete();

            return response()->json([
                'success' => true,
                'message' => 'Component deleted successfully'
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to delete component: ' . $e->getMessage()
            ], 500);
        }
    }

    public function search(Request $request): JsonResponse
    {
        try {
            $validated = $request->validate([
                'query' => 'required|string|max:255',
                'component_type' => 'nullable|in:element,component',
                'category' => 'nullable|string|max:255'
            ]);

            $query = Component::active()->search($validated['query']);

            if (isset($validated['component_type'])) {
                $query->byComponentType($validated['component_type']);
            }

            if (isset($validated['category'])) {
                $query->byCategory($validated['category']);
            }

            $results = $query->ordered()->get()->map(function ($component) {
                $variants = $component->variants;
                if (is_string($variants)) {
                    $variants = json_decode($variants, true);
                }
                
                return [
                    'id' => $component->id,
                    'name' => $component->name,
                    'type' => $component->type,
                    'component_type' => $component->component_type,
                    'category' => $component->category,
                    'alphabet_group' => $component->alphabet_group,
                    'description' => $component->description,
                    'icon' => $component->icon,
                    'variants' => $variants,
                    'has_animation' => $component->has_animation,
                    'animation_type' => $component->animation_type
                ];
            });

            return response()->json([
                'success' => true,
                'data' => $results
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to search components: ' . $e->getMessage()
            ], 500);
        }
    }

    public function getByLetter(Request $request): JsonResponse
    {
        try {
            $validated = $request->validate([
                'letter' => 'required|string|size:1',
                'component_type' => 'required|in:element,component'
            ]);

            $components = Component::active()
                ->byComponentType($validated['component_type'])
                ->byAlphabetGroup($validated['letter'])
                ->ordered()
                ->get()
                ->map(function ($component) {
                    $variants = $component->variants;
                    if (is_string($variants)) {
                        $variants = json_decode($variants, true);
                    }
                    
                    return [
                        'id' => $component->id,
                        'name' => $component->name,
                        'type' => $component->type,
                        'component_type' => $component->component_type,
                        'category' => $component->category,
                        'alphabet_group' => $component->alphabet_group,
                        'description' => $component->description,
                        'icon' => $component->icon,
                        'variants' => $variants,
                        'has_animation' => $component->has_animation,
                        'animation_type' => $component->animation_type
                    ];
                });

            return response()->json([
                'success' => true,
                'data' => $components
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to get components by letter: ' . $e->getMessage()
            ], 500);
        }
    }

    public function generateCode(Request $request): JsonResponse
    {
        try {
            $validated = $request->validate([
                'components' => 'required|array',
                'style' => 'required|string|in:react-tailwind,react-css,html-css,html-tailwind'
            ]);

            $generatedCode = $this->processCodeGeneration($validated['components'], $validated['style']);
            
            return response()->json([
                'success' => true,
                'data' => $generatedCode
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to generate code: ' . $e->getMessage()
            ], 500);
        }
    }

    private function processCodeGeneration(array $components, string $style): array
    {
        if (empty($components)) {
            return $this->getEmptyTemplate($style);
        }

        switch ($style) {
            case 'react-tailwind':
                return $this->generateReactTailwindCode($components);
            case 'react-css':
                return $this->generateReactCSSCode($components);
            case 'html-css':
                return $this->generateHTMLCSSCode($components);
            case 'html-tailwind':
                return $this->generateHTMLTailwindCode($components);
            default:
                return $this->generateReactTailwindCode($components);
        }
    }

    private function getEmptyTemplate(string $style): array
    {
        switch ($style) {
            case 'react-tailwind':
            case 'react-css':
                return [
                    'react' => 'import React from \'react\';

const GeneratedComponent = () => {
  return (
    <div className="relative w-full h-full min-h-[400px] bg-gradient-to-br from-purple-500 to-blue-600 rounded-xl">
      {/* No components yet */}
    </div>
  );
};

export default GeneratedComponent;',
                    'css' => '/* No styles needed yet */',
                    'html' => '',
                    'tailwind' => '// No components to generate classes for'
                ];
            case 'html-css':
            case 'html-tailwind':
                return [
                    'html' => '<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Component</title>
</head>
<body>
    <div class="container">
      <!-- No components yet -->
    </div>
</body>
</html>',
                    'css' => '.container { padding: 20px; }',
                    'react' => '',
                    'tailwind' => ''
                ];
            default:
                return ['html' => '', 'css' => '', 'react' => '', 'tailwind' => ''];
        }
    }

    private function generateReactTailwindCode(array $components): array
    {
        $reactComponents = [];
        $tailwindClasses = [];

        foreach ($components as $comp) {
            $component = Component::where('type', $comp['type'])->first();
            if (!$component) continue;

            $classes = $this->getComponentClasses($comp, $component);
            $tailwindClasses[] = "// {$component->name} ({$comp['type']})\n{$classes}";

            $reactComponents[] = "        <div style={{ position: 'absolute', left: '{$comp['position']['x']}px', top: '{$comp['position']['y']}px' }}>
          {$this->generateComponentJSX($comp, $component, $classes)}
        </div>";
        }

        return [
            'react' => 'import React from \'react\';

const GeneratedComponent = () => {
  return (
    <div className="relative w-full h-full min-h-[400px] bg-gradient-to-br from-purple-500 to-blue-600 rounded-xl">
' . implode("\n", $reactComponents) . '
    </div>
  );
};

export default GeneratedComponent;',
            'tailwind' => implode("\n\n", $tailwindClasses),
            'html' => '',
            'css' => ''
        ];
    }

    private function generateComponentJSX(array $comp, Component $component, string $classes): string
    {
        // Handle variant-specific generation
        $variant = $comp['variant'] ?? null;
        
        if ($variant && $component->variants) {
            $variants = is_string($component->variants) 
                ? json_decode($component->variants, true) 
                : $component->variants;
                
            $variantData = collect($variants)->firstWhere('name', $variant['name']);
            if ($variantData && isset($variantData['preview_code'])) {
                return $variantData['preview_code'];
            }
        }

        // Fallback to default component generation
        switch ($comp['type']) {
            case 'button':
                $disabled = isset($comp['props']['disabled']) && $comp['props']['disabled'] ? ' disabled' : '';
                return "<button className=\"{$classes}\"{$disabled}>{$comp['props']['text']}</button>";
            
            case 'avatar':
                return "<div className=\"{$classes}\"><span>A</span></div>";
            
            case 'badge':
                return "<span className=\"{$classes}\">{$comp['props']['text']}</span>";
            
            case 'card':
                $title = isset($comp['props']['title']) ? "<h3 className=\"font-semibold text-lg mb-2 text-gray-900\">{$comp['props']['title']}</h3>" : '';
                $content = $comp['props']['content'] ?? 'Card content';
                return "<div className=\"{$classes}\">
            {$title}
            <div className=\"text-gray-600\">{$content}</div>
          </div>";
            
            case 'searchbar':
                return "<div className=\"{$classes}\"><input placeholder=\"{$comp['props']['placeholder']}\" /><svg className=\"search-icon\">...</svg></div>";
            
            default:
                return "<div className=\"{$classes}\">{$component->name}</div>";
        }
    }

    private function getComponentClasses(array $comp, Component $component): string
    {
        // Handle variant-specific classes
        $variant = $comp['variant'] ?? null;
        
        if ($variant && $component->variants) {
            $variants = is_string($component->variants) 
                ? json_decode($component->variants, true) 
                : $component->variants;
                
            $variantData = collect($variants)->firstWhere('name', $variant['name']);
            if ($variantData && isset($variantData['classes'])) {
                return $variantData['classes'];
            }
        }

        // Default classes based on component type
        switch ($comp['type']) {
            case 'button':
                return $this->getButtonClasses($comp['props'] ?? []);
            case 'avatar':
                return 'w-12 h-12 bg-gray-300 rounded-full flex items-center justify-center text-gray-600';
            case 'badge':
                return 'inline-block bg-gray-100 text-gray-800 text-sm px-2 py-1 rounded-full';
            case 'card':
                return 'bg-white rounded-lg shadow-md p-6 border border-gray-200';
            case 'searchbar':
                return 'relative flex items-center';
            default:
                return 'p-4 border-2 border-dashed border-gray-300 rounded-lg bg-gray-50';
        }
    }

    private function getButtonClasses(array $props): string
    {
        $baseClasses = "inline-flex items-center justify-center font-medium rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2";
        
        $variantClasses = [
            'primary' => "bg-gradient-to-r from-purple-600 to-blue-600 text-white hover:from-purple-700 hover:to-blue-700 focus:ring-purple-500 shadow-lg hover:shadow-xl",
            'secondary' => "bg-white text-gray-900 border-2 border-gray-200 hover:bg-gray-50 focus:ring-gray-500 shadow-sm hover:shadow-md",
            'success' => "bg-gradient-to-r from-emerald-500 to-teal-600 text-white hover:from-emerald-600 hover:to-teal-700 focus:ring-emerald-500 shadow-lg hover:shadow-xl",
            'warning' => "bg-gradient-to-r from-amber-500 to-orange-500 text-white hover:from-amber-600 hover:to-orange-600 focus:ring-amber-500 shadow-lg hover:shadow-xl",
            'danger' => "bg-gradient-to-r from-red-500 to-pink-600 text-white hover:from-red-600 hover:to-pink-700 focus:ring-red-500 shadow-lg hover:shadow-xl",
            'ghost' => "bg-transparent text-purple-600 hover:bg-purple-50 focus:ring-purple-500 border border-transparent hover:border-purple-200",
            'gradient' => "bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg hover:shadow-xl transform hover:-translate-y-0.5 transition-all",
            'neon' => "bg-black border-2 border-cyan-400 text-cyan-400 shadow-lg shadow-cyan-400/50 hover:shadow-cyan-400/75",
            'glass' => "bg-white/20 backdrop-blur-md border border-white/30 text-white shadow-xl"
        ];
        
        $sizeClasses = [
            'xs' => "px-2 py-1 text-xs",
            'sm' => "px-3 py-1.5 text-sm",
            'md' => "px-6 py-2.5 text-base",
            'lg' => "px-8 py-4 text-lg",
            'xl' => "px-10 py-5 text-xl"
        ];
        
        $variant = $variantClasses[$props['variant'] ?? 'primary'] ?? $variantClasses['primary'];
        $size = $sizeClasses[$props['size'] ?? 'md'] ?? $sizeClasses['md'];
        $custom = $props['className'] ?? '';
        
        return trim("{$baseClasses} {$variant} {$size} {$custom}");
    }

    private function getInputClasses(array $props): string
    {
        $baseClasses = "block w-full rounded-lg border transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-offset-1";
        
        $variantClasses = [
            'default' => "border-gray-300 focus:border-blue-500 focus:ring-blue-500",
            'error' => "border-red-300 focus:border-red-500 focus:ring-red-500",
            'success' => "border-green-300 focus:border-green-500 focus:ring-green-500"
        ];
        
        $sizeClasses = [
            'sm' => "px-3 py-1.5 text-sm",
            'md' => "px-4 py-2.5 text-base",
            'lg' => "px-5 py-3 text-lg"
        ];
        
        $variant = $variantClasses[$props['variant'] ?? 'default'] ?? $variantClasses['default'];
        $size = $sizeClasses[$props['size'] ?? 'md'] ?? $sizeClasses['md'];
        
        return trim("{$baseClasses} {$variant} {$size}");
    }

    private function getCardClasses(array $props): string
    {
        $baseClasses = "rounded-lg border bg-white";
        
        $variantClasses = [
            'default' => "border-gray-200",
            'outlined' => "border-gray-300 bg-transparent",
            'elevated' => "border-transparent shadow-lg"
        ];
        
        $paddingClasses = [
            'sm' => "p-3",
            'md' => "p-4",
            'lg' => "p-6"
        ];
        
        $variant = $variantClasses[$props['variant'] ?? 'default'] ?? $variantClasses['default'];
        $padding = $paddingClasses[$props['padding'] ?? 'md'] ?? $paddingClasses['md'];
        $shadow = (isset($props['shadow']) && $props['shadow'] && ($props['variant'] ?? 'default') !== 'elevated') ? 'shadow-sm' : '';
        
        return trim("{$baseClasses} {$variant} {$padding} {$shadow}");
    }

    private function generateReactCSSCode(array $components): array
    {
        $reactComponents = [];
        
        foreach ($components as $comp) {
            $component = Component::where('type', $comp['type'])->first();
            if (!$component) continue;

            $classes = $this->getCSSClasses($comp, $component);
            $reactComponents[] = "        <div style={{ position: 'absolute', left: '{$comp['position']['x']}px', top: '{$comp['position']['y']}px' }}>
          {$this->generateComponentJSX($comp, $component, $classes)}
        </div>";
        }

        return [
            'react' => 'import React from \'react\';
import \'./GeneratedComponent.css\';

const GeneratedComponent = () => {
  return (
    <div className="canvas-container">
' . implode("\n", $reactComponents) . '
    </div>
  );
};

export default GeneratedComponent;',
            'css' => $this->generateCSSStyles($components),
            'html' => '',
            'tailwind' => ''
        ];
    }

    private function generateHTMLCSSCode(array $components): array
    {
        $htmlComponents = [];
        
        foreach ($components as $comp) {
            $component = Component::where('type', $comp['type'])->first();
            if (!$component) continue;

            $classes = $this->getCSSClasses($comp, $component);
            $htmlComponents[] = "    <div style=\"position: absolute; left: {$comp['position']['x']}px; top: {$comp['position']['y']}px;\">
      {$this->generateComponentHTML($comp, $component, $classes)}
    </div>";
        }

        return [
            'html' => '<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Component</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="canvas-container">
' . implode("\n", $htmlComponents) . '
    </div>
</body>
</html>',
            'css' => $this->generateCSSStyles($components),
            'react' => '',
            'tailwind' => ''
        ];
    }

    private function generateHTMLTailwindCode(array $components): array
    {
        $htmlComponents = [];
        $tailwindClasses = [];

        foreach ($components as $comp) {
            $component = Component::where('type', $comp['type'])->first();
            if (!$component) continue;

            $classes = $this->getComponentClasses($comp, $component);
            $tailwindClasses[] = "/* {$component->name} ({$comp['type']}) */\n{$classes}";

            $htmlComponents[] = "    <div style=\"position: absolute; left: {$comp['position']['x']}px; top: {$comp['position']['y']}px;\">
      {$this->generateComponentHTML($comp, $component, $classes)}
    </div>";
        }

        return [
            'html' => '<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Component</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div class="relative w-full h-full min-h-[400px] bg-gradient-to-br from-purple-500 to-blue-600 rounded-xl">
' . implode("\n", $htmlComponents) . '
    </div>
</body>
</html>',
            'tailwind' => implode("\n\n", $tailwindClasses),
            'css' => '',
            'react' => ''
        ];
    }

    private function generateComponentHTML(array $comp, Component $component, string $classes): string
    {
        switch ($comp['type']) {
            case 'button':
                $disabled = isset($comp['props']['disabled']) && $comp['props']['disabled'] ? ' disabled' : '';
                return "<button class=\"{$classes}\"{$disabled}>{$comp['props']['text']}</button>";
            
            case 'avatar':
                return "<div class=\"{$classes}\"><span>A</span></div>";
            
            case 'badge':
                return "<span class=\"{$classes}\">{$comp['props']['text']}</span>";
            
            case 'card':
                $title = isset($comp['props']['title']) ? "<h3 class=\"font-semibold text-lg mb-2 text-gray-900\">{$comp['props']['title']}</h3>" : '';
                $content = $comp['props']['content'] ?? 'Card content';
                return "<div class=\"{$classes}\">
        {$title}
        <div class=\"text-gray-600\">{$content}</div>
      </div>";
            
            default:
                return "<div class=\"{$classes}\">{$component->name}</div>";
        }
    }

    private function getCSSClasses(array $comp, Component $component): string
    {
        switch ($comp['type']) {
            case 'button':
                $variant = $comp['props']['variant'] ?? 'primary';
                $size = $comp['props']['size'] ?? 'md';
                return "btn btn-{$variant} btn-{$size}";
            case 'avatar':
                return 'avatar';
            case 'badge':
                $variant = $comp['props']['variant'] ?? 'default';
                return "badge badge-{$variant}";
            case 'card':
                return 'card';
            default:
                return 'component-default';
        }
    }

    private function generateCSSStyles(array $components): string
    {
        return '.canvas-container {
  position: relative;
  width: 100%;
  height: 100%;
  min-height: 400px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 12px;
}

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-weight: 500;
  border-radius: 8px;
  transition: all 0.2s ease;
  border: none;
  cursor: pointer;
  font-family: \'Inter\', sans-serif;
}

.btn:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
}

.btn-primary {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  box-shadow: 0 4px 14px rgba(102, 126, 234, 0.4);
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
}

.btn-secondary {
  background: white;
  color: #374151;
  border: 2px solid #e5e7eb;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.btn-secondary:hover {
  background: #f9fafb;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.btn-success {
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  color: white;
  box-shadow: 0 4px 14px rgba(16, 185, 129, 0.4);
}

.btn-warning {
  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
  color: white;
  box-shadow: 0 4px 14px rgba(245, 158, 11, 0.4);
}

.btn-danger {
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  color: white;
  box-shadow: 0 4px 14px rgba(239, 68, 68, 0.4);
}

.btn-sm {
  padding: 6px 12px;
  font-size: 0.875rem;
}

.btn-md {
  padding: 10px 24px;
  font-size: 1rem;
}

.btn-lg {
  padding: 16px 32px;
  font-size: 1.125rem;
}

/* Input styles */
.input {
  display: block;
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 1rem;
  transition: all 0.2s ease;
}

.input:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

/* Card styles */
.card {
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 1rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* Avatar styles */
.avatar {
  width: 3rem;
  height: 3rem;
  background-color: #d1d5db;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #6b7280;
}

/* Badge styles */
.badge {
  display: inline-block;
  padding: 0.25rem 0.5rem;
  border-radius: 9999px;
  font-size: 0.875rem;
  font-weight: 500;
}

.badge-default {
  background-color: #f3f4f6;
  color: #374151;
}

.badge-primary {
  background-color: #dbeafe;
  color: #1d4ed8;
}

.badge-success {
  background-color: #dcfce7;
  color: #166534;
}

.badge-warning {
  background-color: #fef3c7;
  color: #92400e;
}

.badge-danger {
  background-color: #fee2e2;
  color: #991b1b;
}

.component-default {
  padding: 1rem;
  border: 2px dashed #d1d5db;
  border-radius: 8px;
  background-color: #f9fafb;
  text-align: center;
}';
    }
}





<?php
// app/Http/Controllers/ProjectComponentController.php - ENHANCED with Recursive Support

namespace App\Http\Controllers;

use App\Models\ProjectComponent;
use App\Models\Revision;
use App\Models\Project;
use App\Models\Frame;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\DB;

class ProjectComponentController extends Controller
{
    /**
     * Recursively build component tree from flat database records
     */
    private function buildComponentTree($components, $parentId = null)
    {
        $tree = [];
        
        foreach ($components as $component) {
            if ($component->parent_id == $parentId) {
                $node = [
                    'id' => $component->component_instance_id,
                    'type' => $component->component_type,
                    'props' => $component->props,
                    'name' => $component->name,
                    'zIndex' => $component->z_index,
                    'sortOrder' => $component->sort_order,
                    'variant' => $component->variant,
                    'style' => $component->style ?? [],
                    'animation' => $component->animation ?? [],
                    'display_type' => $component->display_type,
                    'layout_props' => $component->layout_props,
                    'isLayoutContainer' => $component->is_layout_container,
                    'visible' => $component->visible ?? true,
                    'locked' => $component->locked ?? false,
                    'children' => $this->buildComponentTree($components, $component->id)
                ];
                
                $tree[] = $node;
            }
        }
        
        // Sort by sort_order
        usort($tree, function($a, $b) {
            return ($a['sortOrder'] ?? 0) - ($b['sortOrder'] ?? 0);
        });
        
        return $tree;
    }

    /**
     * Get components with full hierarchy
     */
    public function index(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'project_id' => 'required|string',
            'frame_id' => 'nullable|string'
        ]);

        $project = Project::where('uuid', $validated['project_id'])->first();
        if (!$project) {
            return response()->json(['success' => false, 'message' => 'Project not found'], 404);
        }

        $query = ProjectComponent::where('project_id', $project->id)
            ->with('component');

        if (isset($validated['frame_id'])) {
            $frame = Frame::where('uuid', $validated['frame_id'])->first();
            if ($frame) {
                $query->where('frame_id', $frame->id);
            }
        }

        $components = $query->orderBy('sort_order')->get();
        
        // Build hierarchical tree
        $tree = $this->buildComponentTree($components);

        return response()->json([
            'success' => true,
            'data' => $tree,
            'meta' => [
                'total_components' => $components->count(),
                'max_depth' => $this->calculateMaxDepth($tree)
            ]
        ]);
    }

    /**
     * Calculate maximum nesting depth
     */
    private function calculateMaxDepth($tree, $currentDepth = 0)
    {
        $maxDepth = $currentDepth;
        
        foreach ($tree as $node) {
            if (isset($node['children']) && count($node['children']) > 0) {
                $childDepth = $this->calculateMaxDepth($node['children'], $currentDepth + 1);
                $maxDepth = max($maxDepth, $childDepth);
            }
        }
        
        return $maxDepth;
    }

  
    
    public function bulkUpdate(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'project_id' => 'required|string',
            'frame_id' => 'required|string',
            'components' => 'required|array',
            'components.*.id' => 'required|string',
            'components.*.type' => 'required|string',
            'components.*.props' => 'nullable|array',
            'components.*.name' => 'required|string',
            'components.*.zIndex' => 'nullable|integer',
            'components.*.sortOrder' => 'nullable|integer',
            'components.*.variant' => 'nullable|array',
            'components.*.style' => 'nullable|array',
            'components.*.animation' => 'nullable|array',
            'components.*.isLayoutContainer' => 'nullable|boolean',
            'components.*.children' => 'nullable|array',
            'create_revision' => 'boolean'
        ]);
    
        DB::beginTransaction();
        
        try {
            $frame = Frame::where('uuid', $validated['frame_id'])->first();
            $project = Project::where('uuid', $validated['project_id'])->first();
            
            if (!$frame || !$project) {
                return response()->json([
                    'success' => false,
                    'message' => 'Frame or project not found'
                ], 404);
            }
    
            // CRITICAL FIX: Delete existing components FIRST
            ProjectComponent::where('project_id', $project->id)
                           ->where('frame_id', $frame->id)
                           ->delete();
    
            // CRITICAL FIX: Track saved component IDs to prevent duplicates
            $savedComponentIds = [];
            
            // Save components recursively (only root-level components)
            foreach ($validated['components'] as $componentData) {
                // CRITICAL: Skip if already saved (prevents duplicates)
                if (in_array($componentData['id'], $savedComponentIds)) {
                    \Log::warning('Skipping duplicate component:', ['id' => $componentData['id']]);
                    continue;
                }
                
                $this->saveComponentTreeWithTracking(
                    $componentData, 
                    $project->id, 
                    $frame->id,
                    null, // no parent for root components
                    0,    // depth 0
                    $savedComponentIds
                );
            }
    
            DB::commit();
    
            return response()->json([
                'success' => true,
                'message' => 'Components saved successfully',
                'saved_count' => count($savedComponentIds)
            ]);
    
        } catch (\Exception $e) {
            DB::rollback();
            
            \Log::error('BulkUpdate failed:', [
                'error' => $e->getMessage(),
                'line' => $e->getLine(),
                'file' => $e->getFile()
            ]);
            
            return response()->json([
                'success' => false,
                'message' => 'Failed to save: ' . $e->getMessage()
            ], 500);
        }
    }
    
    // CRITICAL: New method with duplicate tracking
    private function saveComponentTreeWithTracking($componentData, $projectId, $frameId, $parentDbId = null, $depth = 0, &$savedComponentIds)
    {
        if ($depth > 20) {
            \Log::warning('Max depth reached', ['component' => $componentData['id'] ?? 'unknown']);
            return null;
        }
        
        // CRITICAL: Check if already saved
        if (in_array($componentData['id'], $savedComponentIds)) {
            \Log::warning('Component already saved, skipping:', ['id' => $componentData['id']]);
            return null;
        }
    
        // CRITICAL: Create component
        $component = ProjectComponent::create([
            'project_id' => $projectId,
            'frame_id' => $frameId,
            'parent_id' => $parentDbId,
            'component_instance_id' => $componentData['id'],
            'component_type' => $componentData['type'],
            'props' => $componentData['props'] ?? [],
            'name' => $componentData['name'],
            'z_index' => $componentData['zIndex'] ?? 0,
            'sort_order' => $componentData['sortOrder'] ?? 0,
            'variant' => $componentData['variant'] ?? null,
            'style' => $componentData['style'] ?? [],
            'animation' => $componentData['animation'] ?? [],
            'is_layout_container' => $componentData['isLayoutContainer'] ?? false,
            'visible' => $componentData['visible'] ?? true,
            'locked' => $componentData['locked'] ?? false,
        ]);
        
        // CRITICAL: Mark as saved
        $savedComponentIds[] = $componentData['id'];
    
        // Recursively save children
        if (isset($componentData['children']) && is_array($componentData['children'])) {
            foreach ($componentData['children'] as $childData) {
                $this->saveComponentTreeWithTracking(
                    $childData, 
                    $projectId, 
                    $frameId, 
                    $component->id, 
                    $depth + 1,
                    $savedComponentIds
                );
            }
        }
    
        return $component;
    }
    
    private function saveComponentTree($componentData, $projectId, $frameId, $parentDbId = null, $depth = 0)
    {
        if ($depth > 20) {
            \Log::warning('Max depth reached', ['component' => $componentData['id'] ?? 'unknown']);
            return null;
        }
    
        // CRITICAL: Map frontend field names to backend
        $component = ProjectComponent::create([
            'project_id' => $projectId,
            'frame_id' => $frameId,
            'parent_id' => $parentDbId,
            'component_instance_id' => $componentData['id'],              // id → component_instance_id
            'component_type' => $componentData['type'],                    // type → component_type
            'props' => $componentData['props'] ?? [],
            'name' => $componentData['name'],
            'z_index' => $componentData['zIndex'] ?? 0,
            'sort_order' => $componentData['sortOrder'] ?? 0,
            'variant' => $componentData['variant'] ?? null,
            'style' => $componentData['style'] ?? [],
            'animation' => $componentData['animation'] ?? [],
            'is_layout_container' => $componentData['isLayoutContainer'] ?? false,
            'visible' => $componentData['visible'] ?? true,
            'locked' => $componentData['locked'] ?? false,
        ]);
    
        // Recursively save children
        if (isset($componentData['children']) && is_array($componentData['children'])) {
            foreach ($componentData['children'] as $childData) {
                $this->saveComponentTree($childData, $projectId, $frameId, $component->id, $depth + 1);
            }
        }
    
        return $component;
    }

    /**
     * Move component to different parent (change nesting)
     */
    public function moveComponent(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'project_id' => 'required|string',
            'frame_id' => 'required|string',
            'component_id' => 'required|string',
            'new_parent_id' => 'nullable|string',
            'new_index' => 'integer|min:0'
        ]);

        DB::beginTransaction();
        
        try {
            $project = Project::where('uuid', $validated['project_id'])->first();
            $frame = Frame::where('uuid', $validated['frame_id'])->first();
            
            $component = ProjectComponent::where('project_id', $project->id)
                ->where('frame_id', $frame->id)
                ->where('component_instance_id', $validated['component_id'])
                ->first();

            if (!$component) {
                return response()->json(['success' => false, 'message' => 'Component not found'], 404);
            }

            // Get new parent's database ID if provided
            $newParentDbId = null;
            if ($validated['new_parent_id']) {
                $newParent = ProjectComponent::where('project_id', $project->id)
                    ->where('frame_id', $frame->id)
                    ->where('component_instance_id', $validated['new_parent_id'])
                    ->first();
                    
                if ($newParent) {
                    $newParentDbId = $newParent->id;
                }
            }

            // Update component's parent
            $component->update([
                'parent_id' => $newParentDbId,
                'sort_order' => $validated['new_index']
            ]);

            DB::commit();

            return response()->json([
                'success' => true,
                'message' => 'Component moved successfully',
                'data' => $component
            ]);

        } catch (\Exception $e) {
            DB::rollback();
            return response()->json([
                'success' => false,
                'message' => 'Failed to move component: ' . $e->getMessage()
            ], 500);
        }
    }
}




<?php
// database/seeders/LayoutContainerSeeder.php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\Component;

class LayoutContainerSeeder extends Seeder
{
    public function run(): void
    {
        $layoutContainers = [
            // SECTION - Main page structure container
            [
                'name' => 'Section',
                'type' => 'section',
                'component_type' => 'element',
                'category' => 'layout',
                'alphabet_group' => 'S',
                'description' => 'Semantic section element - main page structure container',
                'icon' => 'Layout',
                'default_props' => [
                    'className' => 'w-full'
                ],
                'prop_definitions' => [
                    'padding' => ['type' => 'select', 'label' => 'Padding', 'options' => ['py-8 px-4', 'py-16 px-6', 'py-24 px-8'], 'default' => 'py-16 px-6'],
                    'background' => ['type' => 'string', 'label' => 'Background', 'default' => 'transparent'],
                    'maxWidth' => ['type' => 'select', 'label' => 'Max Width', 'options' => ['full', 'container', 'screen'], 'default' => 'full']
                ],
                'render_template' => 'section-template',
                'code_generators' => ['react-tailwind' => 'templates/layout/section.js'],
                'variants' => [
                    [
                        'name' => 'Hero Section',
                        'description' => 'Large hero section with gradient background',
                        'props' => [
                            'padding' => 'py-32 px-8',
                            'background' => 'bg-gradient-to-r from-blue-600 to-purple-600',
                            'className' => 'w-full min-h-screen flex items-center justify-center text-white'
                        ],
                        'preview_code' => '<section class="w-full min-h-screen flex items-center justify-center bg-gradient-to-r from-blue-600 to-purple-600 text-white py-32 px-8"><div class="text-center"><h1 class="text-6xl font-bold mb-6">Hero Title</h1><p class="text-xl mb-8">Amazing subtitle here</p><button class="bg-white text-blue-600 px-8 py-4 rounded-lg font-semibold hover:bg-gray-100 transition-colors">Get Started</button></div></section>'
                    ],
                    [
                        'name' => 'Content Section',
                        'description' => 'Standard content section with container',
                        'props' => [
                            'padding' => 'py-16 px-6',
                            'background' => 'bg-gray-50',
                            'className' => 'w-full'
                        ],
                        'preview_code' => '<section class="w-full py-16 px-6 bg-gray-50"><div class="max-w-7xl mx-auto"><h2 class="text-3xl font-bold mb-8 text-center">Our Services</h2><div class="grid grid-cols-1 md:grid-cols-3 gap-8"><!-- Content goes here --></div></div></section>'
                    ],
                    [
                        'name' => 'Full Height Section',
                        'description' => 'Full viewport height section',
                        'props' => [
                            'padding' => 'py-0 px-0',
                            'background' => 'bg-black',
                            'className' => 'w-full h-screen flex items-center justify-center'
                        ],
                        'preview_code' => '<section class="w-full h-screen flex items-center justify-center bg-black text-white"><div class="text-center"><h1 class="text-5xl font-bold mb-4">Full Height Section</h1><p class="text-xl">Perfect for landing pages</p></div></section>'
                    ]
                ],
                'has_animation' => false,
                'animation_type' => null,
                'sort_order' => 1
            ],

            // CONTAINER - Content width container
            [
                'name' => 'Container',
                'type' => 'container',
                'component_type' => 'element',
                'category' => 'layout',
                'alphabet_group' => 'C',
                'description' => 'Content width container with max-width constraints',
                'icon' => 'Square',
                'default_props' => [
                    'maxWidth' => 'max-w-7xl',
                    'centered' => 'mx-auto',
                    'padding' => 'px-6',
                    'className' => 'w-full'
                ],
                'prop_definitions' => [
                    'maxWidth' => ['type' => 'select', 'label' => 'Max Width', 'options' => ['max-w-sm', 'max-w-md', 'max-w-lg', 'max-w-xl', 'max-w-2xl', 'max-w-4xl', 'max-w-6xl', 'max-w-7xl', 'max-w-full'], 'default' => 'max-w-7xl'],
                    'centered' => ['type' => 'boolean', 'label' => 'Center Container', 'default' => true],
                    'padding' => ['type' => 'select', 'label' => 'Padding', 'options' => ['px-4', 'px-6', 'px-8'], 'default' => 'px-6']
                ],
                'render_template' => 'container-template',
                'code_generators' => ['react-tailwind' => 'templates/layout/container.js'],
                'variants' => [
                    [
                        'name' => 'Centered Container',
                        'description' => 'Standard centered content container',
                        'props' => [
                            'maxWidth' => 'max-w-6xl',
                            'centered' => 'mx-auto',
                            'padding' => 'px-6',
                            'className' => 'w-full'
                        ],
                        'preview_code' => '<div class="w-full max-w-6xl mx-auto px-6"><div class="bg-white rounded-lg shadow-sm border p-8"><h3 class="text-2xl font-bold mb-4">Centered Content</h3><p class="text-gray-600">This content is perfectly centered and constrained to a readable width.</p></div></div>'
                    ],
                    [
                        'name' => 'Narrow Container',
                        'description' => 'Narrow container for forms and focused content',
                        'props' => [
                            'maxWidth' => 'max-w-2xl',
                            'centered' => 'mx-auto',
                            'padding' => 'px-8',
                            'className' => 'w-full'
                        ],
                        'preview_code' => '<div class="w-full max-w-2xl mx-auto px-8"><div class="bg-white rounded-lg shadow-lg p-8"><h2 class="text-3xl font-bold mb-6 text-center">Sign Up</h2><form class="space-y-4"><input class="w-full px-4 py-3 border rounded-lg" placeholder="Email" /><button class="w-full bg-blue-600 text-white py-3 rounded-lg font-semibold">Continue</button></form></div></div>'
                    ],
                    [
                        'name' => 'Wide Container',
                        'description' => 'Wide container for dashboards and data',
                        'props' => [
                            'maxWidth' => 'max-w-full',
                            'centered' => 'mx-auto',
                            'padding' => 'px-4',
                            'className' => 'w-full'
                        ],
                        'preview_code' => '<div class="w-full max-w-full mx-auto px-4"><div class="bg-white rounded-lg shadow-sm border overflow-hidden"><div class="p-6 border-b"><h2 class="text-2xl font-bold">Dashboard</h2></div><div class="p-6 grid grid-cols-1 md:grid-cols-4 gap-6"><!-- Dashboard content --></div></div></div>'
                    ]
                ],
                'has_animation' => false,
                'animation_type' => null,
                'sort_order' => 2
            ],

            // FLEX CONTAINER - Flexible layout system
            [
                'name' => 'Flex Container',
                'type' => 'flex',
                'component_type' => 'element',
                'category' => 'layout',
                'alphabet_group' => 'F',
                'description' => 'Flexible layout container with advanced flexbox controls',
                'icon' => 'Columns',
                'default_props' => [
                    'direction' => 'flex-row',
                    'justify' => 'justify-start',
                    'align' => 'items-stretch',
                    'gap' => 'gap-4',
                    'wrap' => 'flex-nowrap',
                    'className' => 'w-full h-full flex'
                ],
                'prop_definitions' => [
                    'direction' => ['type' => 'select', 'label' => 'Direction', 'options' => ['flex-row', 'flex-col', 'flex-row-reverse', 'flex-col-reverse'], 'default' => 'flex-row'],
                    'justify' => ['type' => 'select', 'label' => 'Justify', 'options' => ['justify-start', 'justify-center', 'justify-end', 'justify-between', 'justify-around', 'justify-evenly'], 'default' => 'justify-start'],
                    'align' => ['type' => 'select', 'label' => 'Align', 'options' => ['items-start', 'items-center', 'items-end', 'items-baseline', 'items-stretch'], 'default' => 'items-stretch'],
                    'gap' => ['type' => 'select', 'label' => 'Gap', 'options' => ['gap-0', 'gap-1', 'gap-2', 'gap-4', 'gap-6', 'gap-8', 'gap-12'], 'default' => 'gap-4'],
                    'wrap' => ['type' => 'select', 'label' => 'Wrap', 'options' => ['flex-nowrap', 'flex-wrap', 'flex-wrap-reverse'], 'default' => 'flex-nowrap']
                ],
                'render_template' => 'flex-template',
                'code_generators' => ['react-tailwind' => 'templates/layout/flex.js'],
                'variants' => [
                    [
                        'name' => 'Navbar Layout',
                        'description' => 'Horizontal navbar with space between items',
                        'props' => [
                            'direction' => 'flex-row',
                            'justify' => 'justify-between',
                            'align' => 'items-center',
                            'gap' => 'gap-8',
                            'className' => 'w-full p-6 bg-white border-b'
                        ],
                        'preview_code' => '<div class="w-full p-6 bg-white border-b flex flex-row justify-between items-center gap-8"><div class="font-bold text-2xl text-gray-900">Logo</div><nav class="flex gap-6"><a class="text-gray-600 hover:text-gray-900">Home</a><a class="text-gray-600 hover:text-gray-900">About</a><a class="text-gray-600 hover:text-gray-900">Contact</a></nav><button class="bg-blue-600 text-white px-6 py-2 rounded-lg">Sign In</button></div>'
                    ],
                    [
                        'name' => 'Card Grid',
                        'description' => 'Responsive card layout with flexbox',
                        'props' => [
                            'direction' => 'flex-row',
                            'justify' => 'justify-center',
                            'align' => 'items-stretch',
                            'gap' => 'gap-6',
                            'wrap' => 'flex-wrap',
                            'className' => 'w-full p-8'
                        ],
                        'preview_code' => '<div class="w-full p-8 flex flex-row justify-center items-stretch gap-6 flex-wrap"><div class="bg-white rounded-xl shadow-lg p-6 flex-1 min-w-72"><h3 class="text-xl font-bold mb-4">Feature 1</h3><p class="text-gray-600">Description here</p></div><div class="bg-white rounded-xl shadow-lg p-6 flex-1 min-w-72"><h3 class="text-xl font-bold mb-4">Feature 2</h3><p class="text-gray-600">Description here</p></div></div>'
                    ],
                    [
                        'name' => 'Sidebar Layout',
                        'description' => 'Sidebar with main content area',
                        'props' => [
                            'direction' => 'flex-row',
                            'justify' => 'justify-start',
                            'align' => 'items-stretch',
                            'gap' => 'gap-0',
                            'className' => 'w-full h-screen'
                        ],
                        'preview_code' => '<div class="w-full h-screen flex flex-row"><aside class="w-64 bg-gray-900 text-white p-6"><h2 class="text-xl font-bold mb-6">Navigation</h2><nav class="space-y-2"><a class="block py-2 px-4 rounded hover:bg-gray-700">Dashboard</a><a class="block py-2 px-4 rounded hover:bg-gray-700">Projects</a></nav></aside><main class="flex-1 bg-gray-50 p-8"><h1 class="text-3xl font-bold mb-6">Main Content</h1><p>Content goes here...</p></main></div>'
                    ]
                ],
                'has_animation' => false,
                'animation_type' => null,
                'sort_order' => 3
            ],

            // GRID CONTAINER - CSS Grid system
            [
                'name' => 'Grid Container',
                'type' => 'grid',
                'component_type' => 'element',
                'category' => 'layout',
                'alphabet_group' => 'G',
                'description' => 'Advanced CSS Grid container with responsive capabilities',
                'icon' => 'Grid3X3',
                'default_props' => [
                    'columns' => 'grid-cols-3',
                    'rows' => 'grid-rows-auto',
                    'gap' => 'gap-6',
                    'autoFlow' => 'grid-flow-row',
                    'placeItems' => 'place-items-stretch',
                    'className' => 'w-full h-full grid'
                ],
                'prop_definitions' => [
                    'columns' => ['type' => 'select', 'label' => 'Columns', 'options' => ['grid-cols-1', 'grid-cols-2', 'grid-cols-3', 'grid-cols-4', 'grid-cols-5', 'grid-cols-6', 'grid-cols-12'], 'default' => 'grid-cols-3'],
                    'rows' => ['type' => 'select', 'label' => 'Rows', 'options' => ['grid-rows-auto', 'grid-rows-1', 'grid-rows-2', 'grid-rows-3', 'grid-rows-4'], 'default' => 'grid-rows-auto'],
                    'gap' => ['type' => 'select', 'label' => 'Gap', 'options' => ['gap-0', 'gap-2', 'gap-4', 'gap-6', 'gap-8', 'gap-12'], 'default' => 'gap-6']
                ],
                'render_template' => 'grid-template',
                'code_generators' => ['react-tailwind' => 'templates/layout/grid.js'],
                'variants' => [
                    [
                        'name' => 'Dashboard Grid',
                        'description' => 'Dashboard layout with different sized panels',
                        'props' => [
                            'columns' => 'grid-cols-12',
                            'rows' => 'grid-rows-4',
                            'gap' => 'gap-6',
                            'className' => 'w-full h-screen p-6 grid'
                        ],
                        'preview_code' => '<div class="w-full h-screen p-6 grid grid-cols-12 grid-rows-4 gap-6"><div class="col-span-8 row-span-2 bg-white rounded-xl shadow-lg p-6 border"><h2 class="text-2xl font-bold mb-4">Main Chart</h2><div class="bg-gray-100 h-full rounded-lg flex items-center justify-center">Chart Area</div></div><div class="col-span-4 row-span-1 bg-white rounded-xl shadow-lg p-6 border"><h3 class="font-bold mb-2">Stats</h3><p class="text-3xl font-bold text-blue-600">$12,345</p></div><div class="col-span-4 row-span-1 bg-white rounded-xl shadow-lg p-6 border"><h3 class="font-bold mb-2">Users</h3><p class="text-3xl font-bold text-green-600">1,234</p></div></div>'
                    ],
                    [
                        'name' => 'Photo Gallery',
                        'description' => 'Responsive photo gallery grid',
                        'props' => [
                            'columns' => 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4',
                            'gap' => 'gap-4',
                            'className' => 'w-full p-6 grid'
                        ],
                        'preview_code' => '<div class="w-full p-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"><div class="aspect-square bg-gradient-to-br from-pink-400 to-purple-600 rounded-lg"></div><div class="aspect-square bg-gradient-to-br from-blue-400 to-cyan-600 rounded-lg"></div><div class="aspect-square bg-gradient-to-br from-green-400 to-blue-600 rounded-lg"></div><div class="aspect-square bg-gradient-to-br from-yellow-400 to-orange-600 rounded-lg"></div></div>'
                    ],
                    [
                        'name' => 'Magazine Layout',
                        'description' => 'Magazine-style complex grid layout',
                        'props' => [
                            'columns' => 'grid-cols-6',
                            'rows' => 'grid-rows-6',
                            'gap' => 'gap-4',
                            'className' => 'w-full h-screen p-6 grid'
                        ],
                        'preview_code' => '<div class="w-full h-screen p-6 grid grid-cols-6 grid-rows-6 gap-4"><div class="col-span-4 row-span-3 bg-gradient-to-br from-purple-600 to-blue-600 rounded-xl text-white p-8 flex items-end"><h1 class="text-4xl font-bold">Featured Article</h1></div><div class="col-span-2 row-span-2 bg-white rounded-xl shadow-lg p-6 border"><h3 class="font-bold mb-2">Side Story 1</h3></div><div class="col-span-2 row-span-1 bg-white rounded-xl shadow-lg p-4 border"><h4 class="font-semibold">Quick News</h4></div></div>'
                    ]
                ],
                'has_animation' => false,
                'animation_type' => null,
                'sort_order' => 4
            ],

            // DIV - Generic container
            [
                'name' => 'Div Container',
                'type' => 'div',
                'component_type' => 'element',
                'category' => 'layout',
                'alphabet_group' => 'D',
                'description' => 'Generic div container - fully customizable building block',
                'icon' => 'Square',
                'default_props' => [
                    'display' => 'block',
                    'className' => 'w-full h-auto'
                ],
                'prop_definitions' => [
                    'display' => ['type' => 'select', 'label' => 'Display', 'options' => ['block', 'flex', 'grid', 'inline-block', 'inline-flex'], 'default' => 'block']
                ],
                'render_template' => 'div-template',
                'code_generators' => ['react-tailwind' => 'templates/layout/div.js'],
                'variants' => [
                    [
                        'name' => 'Content Block',
                        'description' => 'Basic content container',
                        'props' => [
                            'className' => 'w-full p-6 bg-white rounded-lg border'
                        ],
                        'preview_code' => '<div class="w-full p-6 bg-white rounded-lg border"><div class="h-32 bg-gray-100 rounded-lg flex items-center justify-center text-gray-500 text-sm font-medium">Content Block</div></div>'
                    ],
                    [
                        'name' => 'Card Wrapper',
                        'description' => 'Card-style wrapper with shadow',
                        'props' => [
                            'className' => 'w-full max-w-md mx-auto bg-white rounded-xl shadow-lg overflow-hidden'
                        ],
                        'preview_code' => '<div class="w-full max-w-md mx-auto bg-white rounded-xl shadow-lg overflow-hidden"><div class="p-8"><div class="h-24 bg-gradient-to-r from-blue-500 to-purple-600 rounded-lg mb-4"></div><h3 class="text-xl font-bold text-gray-900">Card Title</h3><p class="text-gray-600 mt-2">Card description goes here</p></div></div>'
                    ],
                    [
                        'name' => 'Overlay Container',
                        'description' => 'Container with overlay capabilities',
                        'props' => [
                            'className' => 'relative w-full h-64 bg-gray-900 rounded-lg overflow-hidden'
                        ],
                        'preview_code' => '<div class="relative w-full h-64 bg-gray-900 rounded-lg overflow-hidden"><div class="absolute inset-0 bg-gradient-to-t from-black/60 to-transparent"></div><div class="absolute bottom-6 left-6 text-white"><h3 class="text-2xl font-bold">Overlay Content</h3><p class="text-gray-200">Perfect for hero sections</p></div></div>'
                    ]
                ],
                'has_animation' => false,
                'animation_type' => null,
                'sort_order' => 5
            ]
        ];

        foreach ($layoutContainers as $container) {
            Component::create($container);
        }
    }
}




<?php
// app/Models/Component.php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Component extends Model
{
    use HasFactory;

    protected $fillable = [
        'name',
        'type',
        'component_type',
        'category',
        'alphabet_group',
        'description',
        'icon',
        'default_props',
        'prop_definitions',
        'render_template',
        'code_generators',
        'variants',
        'has_animation',
        'animation_type',
        'is_active',
        'sort_order'
    ];

    protected $casts = [
        'default_props' => 'array',
        'prop_definitions' => 'array',
        'code_generators' => 'array',
        'variants' => 'array',
        'is_active' => 'boolean',
        'has_animation' => 'boolean'
    ];

    public function projectComponents()
    {
        return $this->hasMany(ProjectComponent::class, 'component_type', 'type');
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeByCategory($query, $category)
    {
        return $query->where('category', $category);
    }

    public function scopeByComponentType($query, $type)
    {
        return $query->where('component_type', $type);
    }

    public function scopeByAlphabetGroup($query, $letter)
    {
        return $query->where('alphabet_group', strtoupper($letter));
    }

    public function scopeOrdered($query)
    {
        return $query->orderBy('component_type')
                     ->orderBy('alphabet_group')
                     ->orderBy('category')
                     ->orderBy('sort_order')
                     ->orderBy('name');
    }

    public function scopeSearch($query, $search)
    {
        if (empty($search)) {
            return $query;
        }

        return $query->where(function ($q) use ($search) {
            $q->where('name', 'like', '%' . $search . '%')
              ->orWhere('description', 'like', '%' . $search . '%')
              ->orWhere('category', 'like', '%' . $search . '%');
        });
    }
}




<?php
// app/Models/ProjectComponent.php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class ProjectComponent extends Model
{
    use HasFactory;

    protected $fillable = [
        'project_id',
        'frame_id', // Change from frame_uuid to frame_id for consistency
        'parent_id',
        'component_instance_id',
        'component_type',
        'props',
        'name',
        'z_index',
        'sort_order',
        'is_locked',
        'variant',        // ADD
        'style',          // ADD
        'animation',      // ADD
        'display_type',      // 'block', 'flex', 'grid', 'inline-block', etc.
        'layout_props',      // flexDirection, gap, gridTemplateColumns, etc.
        'is_layout_container', // boolean
        'created_at',
        'updated_at'
    ];
    
    protected $casts = [
        'props' => 'array',
        'is_locked' => 'boolean',
        'variant' => 'array',     // ADD
        'style' => 'array',       // ADD
        'animation' => 'array',   // ADD
        'layout_props' => 'array',
        'is_layout_container' => 'boolean',
    ];
    
    // ADD this relationship
  public function parent()
  {
      return $this->belongsTo(ProjectComponent::class, 'parent_id');
  }
  
  // ADD this relationship
  public function children()
  {
      return $this->hasMany(ProjectComponent::class, 'parent_id');
  }
    

    public function component()
    {
        return $this->belongsTo(Component::class, 'component_type', 'type');
    }

    public function scopeByProject($query, $projectId)
    {
        return $query->where('project_id', $projectId);
    }

    public function scopeByFrame($query, $frameId)
    {
        return $query->where('frame_id', $frameId);
    }

    public function scopeOrdered($query)
    {
        return $query->orderBy('z_index')->orderBy('created_at');
    }
}